---
phase: 03-emotional-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - rlm-service/prompt_builder.py
autonomous: true

must_haves:
  truths:
    - "Python PromptBuilder has build_emotionally_intelligent_prompt method"
    - "Python uncertainty, relationship arc, and adaptive tone sections produce character-identical output to TypeScript"
    - "Python build_emotionally_intelligent_prompt composes base + uncertainty + relationship + adaptive tone in same order as TypeScript"
  artifacts:
    - path: "rlm-service/prompt_builder.py"
      provides: "Python PromptBuilder with emotional intelligence prompt construction"
      contains: "build_emotionally_intelligent_prompt"
  key_links:
    - from: "rlm-service/prompt_builder.py"
      to: "lib/soulprint/prompt-builder.ts"
      via: "character-identical output contract"
      pattern: "UNCERTAINTY ACKNOWLEDGMENT|RELATIONSHIP TONE|ADAPTIVE TONE"
---

<objective>
Mirror the TypeScript emotional intelligence prompt sections in the Python PromptBuilder for cross-language consistency.

Purpose: The RLM service (Python) needs to produce identical emotionally intelligent prompts as the TypeScript side. This ensures EMOT-01/02/03 work consistently whether the response comes from Bedrock (TypeScript path) or RLM (Python path). The Python PromptBuilder must have a `build_emotionally_intelligent_prompt` method that produces character-identical output to TypeScript.

Output: Updated `rlm-service/prompt_builder.py` with EI prompt construction methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-emotional-intelligence/03-RESEARCH.md
@.planning/phases/03-emotional-intelligence/03-01-SUMMARY.md
@rlm-service/prompt_builder.py
@lib/soulprint/prompt-builder.ts
@lib/soulprint/emotional-intelligence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emotional intelligence prompt sections to Python PromptBuilder</name>
  <files>rlm-service/prompt_builder.py</files>
  <action>
Add emotional intelligence prompt construction to `rlm-service/prompt_builder.py`. This mirrors the TypeScript PromptBuilder extension and the prompt section builders from `emotional-intelligence.ts`.

**1. Add helper functions BEFORE the PromptBuilder class (module-level, like TypeScript exports):**

```python
def build_uncertainty_instructions() -> str:
    """Returns ## UNCERTAINTY ACKNOWLEDGMENT section. Always included in EI prompts."""
    # Must produce IDENTICAL text to TypeScript buildUncertaintyInstructions()
    return """## UNCERTAINTY ACKNOWLEDGMENT

When you lack sufficient information, acknowledge it explicitly:
- "I don't have enough info about X"
- "I'm not sure, but here's what I do know..."
- "That's outside my knowledge -- want me to search?"

Abstention is better than guessing."""


def build_relationship_arc_instructions(arc: Optional[Dict[str, Any]]) -> str:
    """Returns ## RELATIONSHIP TONE section based on conversation depth."""
    if not arc or "stage" not in arc:
        return ""

    stage = arc["stage"]
    message_count = arc.get("messageCount", 0)

    # Must match TypeScript buildRelationshipArcInstructions character-for-character
    # Use the exact same text as the TypeScript version
    instructions = {
        "early": f"""## RELATIONSHIP TONE (Early conversation: {message_count} messages)

You're still getting to know this person. Your tone should be:
- Slightly more cautious (don't assume too much)
- Ask clarifying questions when context is unclear
- Avoid overly familiar language or inside jokes
- Build trust through reliability and helpfulness
- This is the foundation stage -- focus on understanding their communication style""",

        "developing": f"""## RELATIONSHIP TONE (Developing familiarity: {message_count} messages)

You've had several conversations. Your tone should be:
- Balanced between cautious and confident
- Reference past conversations when relevant
- Start building rapport with light personality
- Still verify assumptions, but with more context awareness
- You can be more direct now, but remain respectful""",

        "established": f"""## RELATIONSHIP TONE (Established relationship: {message_count} messages)

You have substantial conversation history. Your tone should be:
- Confident and familiar
- Reference shared context and past discussions freely
- Use the communication style they've shown preference for
- Be more direct and opinionated (you know them well enough)
- This is a trusted relationship -- act like it""",
    }

    return instructions.get(stage, "")


def build_adaptive_tone_instructions(state: Optional[Dict[str, Any]]) -> str:
    """Returns ## ADAPTIVE TONE section based on detected emotional state."""
    if not state or state.get("primary") == "neutral":
        return ""

    primary = state.get("primary", "neutral")
    cues = state.get("cues", [])
    cues_text = ", ".join(cues) if cues else "none detected"

    # Must match TypeScript buildAdaptiveToneInstructions character-for-character
    adaptations = {
        "frustrated": f"""## ADAPTIVE TONE (User shows frustration)

Signs detected: {cues_text}

Adapt your response:
- Be supportive and empathetic
- Keep responses CONCISE
- Focus on actionable solutions immediately
- Skip pleasantries
- Use confident, direct language""",

        "satisfied": f"""## ADAPTIVE TONE (User is satisfied)

Signs detected: {cues_text}

Adapt your response:
- Match their positive energy (don't overdo it)
- Reinforce what worked
- Build momentum with next steps
- Use encouraging language""",

        "confused": f"""## ADAPTIVE TONE (User is confused)

Signs detected: {cues_text}

Adapt your response:
- SIMPLIFY explanations
- Use concrete examples
- Break down complexity
- Avoid jargon
- Structure with clear steps
- Be patient and thorough""",
    }

    return adaptations.get(primary, "")
```

**2. Add build_emotionally_intelligent_prompt method to the PromptBuilder class:**

```python
def build_emotionally_intelligent_prompt(
    self,
    profile: Dict[str, Any],
    daily_memory: Optional[List[Dict[str, str]]] = None,
    memory_context: Optional[str] = None,
    ai_name: Optional[str] = None,
    is_owner: Optional[bool] = None,
    web_search_context: Optional[str] = None,
    web_search_citations: Optional[List[str]] = None,
    current_date: Optional[str] = None,
    current_time: Optional[str] = None,
    emotional_state: Optional[Dict[str, Any]] = None,
    relationship_arc: Optional[Dict[str, Any]] = None,
) -> str:
    """
    Build emotionally intelligent system prompt.
    Composes: base prompt + uncertainty + relationship arc + adaptive tone.
    Mirrors TypeScript PromptBuilder.buildEmotionallyIntelligentPrompt.
    """
    # Start with base prompt (v1 or v2)
    prompt = self.build_system_prompt(
        profile=profile,
        daily_memory=daily_memory,
        memory_context=memory_context,
        ai_name=ai_name,
        is_owner=is_owner,
        web_search_context=web_search_context,
        web_search_citations=web_search_citations,
        current_date=current_date,
        current_time=current_time,
    )

    # Always include uncertainty acknowledgment (EMOT-02)
    prompt += "\n\n" + build_uncertainty_instructions()

    # Add relationship arc if provided (EMOT-03)
    if relationship_arc:
        arc_text = build_relationship_arc_instructions(relationship_arc)
        if arc_text:
            prompt += "\n\n" + arc_text

    # Add adaptive tone if emotion detected with high confidence (EMOT-01)
    if emotional_state and emotional_state.get("confidence", 0) >= 0.6:
        tone_text = build_adaptive_tone_instructions(emotional_state)
        if tone_text:
            prompt += "\n\n" + tone_text

    return prompt
```

**Critical: The section text (## headings, bullet points, wording) must be CHARACTER-IDENTICAL to what the TypeScript versions produce.** Read the TypeScript `emotional-intelligence.ts` file created in Plan 01 and replicate the exact strings. The test for correctness is: given the same inputs, TypeScript and Python produce byte-identical output.

**Do NOT add emotion detection (detectEmotion) to Python.** The RLM service handles emotion detection differently (it receives emotional_state as a parameter from the TypeScript caller, not detecting it independently). Only the prompt section builders and the `build_emotionally_intelligent_prompt` method are needed.
  </action>
  <verify>
Run `cd /home/drewpullen/clawd/soulprint-landing/rlm-service && python -c "from prompt_builder import PromptBuilder; pb = PromptBuilder('v1-technical'); print(pb.build_emotionally_intelligent_prompt({'soulprint_text': 'test'}, emotional_state={'primary': 'frustrated', 'confidence': 0.8, 'cues': ['short responses']}, relationship_arc={'stage': 'early', 'messageCount': 5})[:200])"` -- prints prompt text without errors.
Verify the file contains: `build_emotionally_intelligent_prompt`, `build_uncertainty_instructions`, `build_relationship_arc_instructions`, `build_adaptive_tone_instructions`.
  </verify>
  <done>
Python PromptBuilder has build_emotionally_intelligent_prompt method that mirrors TypeScript. Prompt section builders (uncertainty, relationship arc, adaptive tone) produce character-identical output. No emotion detection in Python (received as parameter).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cross-language sync test for EI prompt sections</name>
  <files>__tests__/cross-lang/emotional-intelligence-sync.test.ts</files>
  <action>
Create a cross-language sync test that verifies TypeScript and Python produce identical EI prompt sections.

Follow the same pattern used in Phase 2's cross-language sync tests (02-02-PLAN.md, which places tests in `__tests__/cross-lang/`). The test should:

**1. Verify TypeScript imports exist before running tests:**

```typescript
import { describe, it, expect, beforeAll } from 'vitest';
import { execSync } from 'child_process';

// Import TypeScript functions with existence verification
let buildUncertaintyInstructions: () => string;
let buildRelationshipArcInstructions: (arc: { stage: string; messageCount: number }) => string;
let buildAdaptiveToneInstructions: (state: { primary: string; confidence: number; cues: string[] }) => string;

beforeAll(async () => {
  try {
    const module = await import('@/lib/soulprint/emotional-intelligence');
    buildUncertaintyInstructions = module.buildUncertaintyInstructions;
    buildRelationshipArcInstructions = module.buildRelationshipArcInstructions;
    buildAdaptiveToneInstructions = module.buildAdaptiveToneInstructions;

    // Verify exports exist
    if (!buildUncertaintyInstructions || !buildRelationshipArcInstructions || !buildAdaptiveToneInstructions) {
      throw new Error('Missing exports from emotional-intelligence module');
    }
  } catch (error) {
    console.error('Failed to import TypeScript EI functions:', error);
    throw error;
  }
});
```

**2. Python function caller with error handling:**

```typescript
function callPython(functionName: string, ...args: unknown[]): string {
  const argsJson = JSON.stringify(args);
  const script = `
import sys, json
sys.path.insert(0, 'rlm-service')
try:
  from prompt_builder import ${functionName}
except ImportError as e:
  print(f"IMPORT_ERROR: {e}", file=sys.stderr)
  sys.exit(1)
args = json.loads(sys.argv[1])
result = ${functionName}(*args)
print(result, end='')
`;

  try {
    return execSync(`python3 -c "${script.replace(/"/g, '\\"')}" '${argsJson}'`, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
  } catch (error) {
    if (error instanceof Error && error.message.includes('IMPORT_ERROR')) {
      throw new Error(`Python import failed: ${functionName}`);
    }
    throw error;
  }
}
```

**3. Test cases with import verification:**

a. `buildUncertaintyInstructions()` -- no args, direct comparison

b. `buildRelationshipArcInstructions` for each stage:
   - `{ stage: 'early', messageCount: 5 }`
   - `{ stage: 'developing', messageCount: 25 }`
   - `{ stage: 'established', messageCount: 100 }`

c. `buildAdaptiveToneInstructions` for each emotion:
   - `{ primary: 'frustrated', confidence: 0.8, cues: ['short responses', 'repeated question'] }`
   - `{ primary: 'satisfied', confidence: 0.9, cues: ['thanks', 'great'] }`
   - `{ primary: 'confused', confidence: 0.7, cues: ['what do you mean'] }`
   - `{ primary: 'neutral', confidence: 0.5, cues: [] }` -- should return empty string

**4. Each test asserts exact string equality:**
```typescript
expect(typescriptResult).toBe(pythonResult);
```

**5. Use describe/it blocks with vitest:**
```typescript
describe('EI Prompt Sections Cross-Language Sync', () => {
  it('uncertainty instructions match', () => { ... });
  it('relationship arc instructions match for early stage', () => { ... });
  it('relationship arc instructions match for developing stage', () => { ... });
  it('relationship arc instructions match for established stage', () => { ... });
  it('adaptive tone instructions match for frustrated', () => { ... });
  it('adaptive tone instructions match for satisfied', () => { ... });
  it('adaptive tone instructions match for confused', () => { ... });
  it('adaptive tone instructions match for neutral (returns empty)', () => { ... });
});
```

**Important:** Place test in `__tests__/cross-lang/emotional-intelligence-sync.test.ts` to match existing cross-language test conventions (not in `lib/soulprint/__tests__/`). The subprocess approach uses JSON blob serialization for param passing (avoiding shell escaping issues -- per 02-02 decision). If Python is not available in the test environment, wrap tests in try/catch and skip with `it.skipIf`.
  </action>
  <verify>
Run `npx vitest run __tests__/cross-lang/emotional-intelligence-sync.test.ts` -- all tests pass (or skip if Python unavailable).
Verify imports resolve correctly before tests run.
  </verify>
  <done>
Cross-language sync test verifies TypeScript and Python EI prompt sections produce identical output for uncertainty, relationship arc (3 stages), and adaptive tone (4 emotions). Import verification prevents test failures from missing TypeScript exports.
  </done>
</task>

</tasks>

<verification>
- `rlm-service/prompt_builder.py` has `build_emotionally_intelligent_prompt` method
- Python prompt sections (uncertainty, relationship arc, adaptive tone) produce identical text to TypeScript
- Cross-language sync test passes
- Python PromptBuilder still works for existing v1/v2 prompt construction
</verification>

<success_criteria>
- Python PromptBuilder mirrors TypeScript EI prompt construction
- Cross-language sync test confirms character-identical output
- RLM service can use build_emotionally_intelligent_prompt when called with emotional_state and relationship_arc parameters
</success_criteria>

<output>
After completion, create `.planning/phases/03-emotional-intelligence/03-03-SUMMARY.md`
</output>
