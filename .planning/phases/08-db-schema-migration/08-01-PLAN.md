---
phase: 08-db-schema-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260208120000_conversations_table.sql
  - supabase/migrations/20260208120100_chat_messages_conversation_fk.sql
  - supabase/migrations/20260208120200_backfill_default_conversations.sql
autonomous: false

must_haves:
  truths:
    - "A conversations table exists with id, user_id, title, created_at, updated_at columns"
    - "conversations table has RLS policies for SELECT, INSERT, UPDATE, DELETE plus service_role"
    - "chat_messages table has a conversation_id UUID column with FK to conversations(id)"
    - "conversation_id column has an index for query performance"
    - "Every existing chat message has a non-NULL conversation_id pointing to a valid conversation"
    - "Each user with messages has exactly one conversation titled Chat History"
    - "Zero messages are orphaned (conversation_id IS NULL)"
  artifacts:
    - path: "supabase/migrations/20260208120000_conversations_table.sql"
      provides: "conversations table DDL with RLS and indexes"
      contains: "CREATE TABLE IF NOT EXISTS public.conversations"
    - path: "supabase/migrations/20260208120100_chat_messages_conversation_fk.sql"
      provides: "conversation_id FK column on chat_messages"
      contains: "ADD COLUMN IF NOT EXISTS conversation_id UUID"
    - path: "supabase/migrations/20260208120200_backfill_default_conversations.sql"
      provides: "Backfill logic creating default conversations and assigning messages"
      contains: "INSERT INTO public.conversations"
  key_links:
    - from: "chat_messages.conversation_id"
      to: "conversations.id"
      via: "foreign key constraint"
      pattern: "REFERENCES public\\.conversations\\(id\\)"
    - from: "backfill migration"
      to: "conversations + chat_messages"
      via: "INSERT...SELECT then UPDATE"
      pattern: "UPDATE public\\.chat_messages.*SET conversation_id"
---

<objective>
Create the multi-conversation database schema and migrate all existing chat messages into default conversations.

Purpose: Phase 10 (Conversation Management UI) depends on this schema. Every existing user's chat history must be preserved in a default conversation so the transition to multi-conversation is seamless.

Output: Three SQL migration files ready to run in Supabase SQL Editor, plus verified data integrity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-db-schema-migration/08-RESEARCH.md
@supabase/migrations/20250127_chat_messages.sql
@supabase/migrations/20260205_soulprint_tables.sql
@supabase/migrations/20260130_database_fixes.sql
@app/api/chat/messages/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversations table and FK column migrations</name>
  <files>
    supabase/migrations/20260208120000_conversations_table.sql
    supabase/migrations/20260208120100_chat_messages_conversation_fk.sql
  </files>
  <action>
Create two SQL migration files following the patterns established in 20260205_soulprint_tables.sql and 20260130_database_fixes.sql.

**Migration 1: `20260208120000_conversations_table.sql`**

Create the conversations table:
- `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
- `user_id` UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- `title` TEXT NOT NULL DEFAULT 'Chat History'
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()

DO NOT add a UNIQUE constraint on user_id -- users will have multiple conversations in Phase 10.

Add composite index: `idx_conversations_user_created ON conversations(user_id, created_at DESC)`

Enable RLS with 5 policies (matching the pattern from 20260130_database_fixes.sql):
- SELECT: `auth.uid() = user_id`
- INSERT: `auth.uid() = user_id` (WITH CHECK)
- UPDATE: `auth.uid() = user_id`
- DELETE: `auth.uid() = user_id`
- ALL for service_role: `auth.role() = 'service_role'`

Add an updated_at trigger. Reuse the existing `update_updated_at()` function (already defined in 20260205_soulprint_tables.sql) -- just CREATE OR REPLACE it to be safe, then create a trigger `conversations_updated_at`.

**Migration 2: `20260208120100_chat_messages_conversation_fk.sql`**

Add nullable conversation_id column to chat_messages:
- `ALTER TABLE public.chat_messages ADD COLUMN IF NOT EXISTS conversation_id UUID;`
- Add FK constraint with NOT VALID: `REFERENCES public.conversations(id) ON DELETE CASCADE NOT VALID`
- Create index: `idx_chat_messages_conversation ON chat_messages(conversation_id)`
- Create composite index: `idx_chat_messages_conv_created ON chat_messages(conversation_id, created_at DESC)`

Use NOT VALID so the FK is added instantly without scanning existing rows (all currently NULL).

Add a comment at the top of each file explaining what it does, matching the style of existing migrations.
  </action>
  <verify>
Read both files and confirm:
1. conversations table has all 5 columns (id, user_id, title, created_at, updated_at)
2. No UNIQUE constraint on user_id
3. RLS enabled with 5 policies (including service_role)
4. updated_at trigger exists
5. conversation_id column added as nullable UUID
6. FK constraint uses NOT VALID and ON DELETE CASCADE
7. Both indexes exist on chat_messages (single and composite)
  </verify>
  <done>
Two migration SQL files exist with correct DDL for conversations table (with RLS, indexes, trigger) and chat_messages FK column (with NOT VALID constraint and indexes).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backfill and verification migration</name>
  <files>
    supabase/migrations/20260208120200_backfill_default_conversations.sql
  </files>
  <action>
Create the backfill migration file `20260208120200_backfill_default_conversations.sql`.

This migration does three things in sequence:

**Step 1: Create one default conversation per user who has messages.**

Use INSERT...SELECT with WHERE NOT EXISTS (NOT ON CONFLICT -- there is no unique constraint on user_id):

```sql
INSERT INTO public.conversations (user_id, title, created_at, updated_at)
SELECT
  cm.user_id,
  'Chat History' AS title,
  MIN(cm.created_at) AS created_at,
  MAX(cm.created_at) AS updated_at
FROM public.chat_messages cm
WHERE NOT EXISTS (
  SELECT 1 FROM public.conversations c WHERE c.user_id = cm.user_id
)
GROUP BY cm.user_id;
```

Set created_at to user's earliest message timestamp and updated_at to their latest.

**Step 2: Assign all NULL-conversation messages to their user's default conversation.**

```sql
UPDATE public.chat_messages cm
SET conversation_id = (
  SELECT c.id
  FROM public.conversations c
  WHERE c.user_id = cm.user_id
  ORDER BY c.created_at ASC
  LIMIT 1
)
WHERE cm.conversation_id IS NULL;
```

Use ORDER BY c.created_at ASC LIMIT 1 to pick the earliest conversation (the default one) -- important for Phase 10 when users have multiple conversations.

**Step 3: Validate the FK constraint** (now that all rows have valid conversation_ids):

```sql
ALTER TABLE public.chat_messages VALIDATE CONSTRAINT fk_chat_messages_conversation;
```

**Step 4: Verification block** using a DO $$ block that:
- Counts total messages
- Counts messages with conversation_id IS NULL (orphaned)
- Counts distinct users with messages
- Counts conversations
- RAISES EXCEPTION if orphaned_messages > 0
- RAISES EXCEPTION if user count mismatch (users with messages != users with conversations)
- RAISES NOTICE with all statistics on success

Follow the exact verification pattern from the research (08-RESEARCH.md Pattern 3).

Add a header comment explaining this is a one-time backfill migration for multi-conversation support.
  </action>
  <verify>
Read the file and confirm:
1. INSERT...SELECT uses WHERE NOT EXISTS (not ON CONFLICT)
2. UPDATE uses subquery with ORDER BY created_at ASC LIMIT 1
3. VALIDATE CONSTRAINT runs after backfill
4. DO $$ block checks for orphaned messages AND user count mismatch
5. Raises EXCEPTION on failure, NOTICE on success
  </verify>
  <done>
Backfill migration file exists with correct INSERT, UPDATE, VALIDATE, and verification logic. The file is ready to be run in Supabase SQL Editor after migrations 1 and 2.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Run migrations in Supabase SQL Editor and verify</name>
  <what-built>
Three SQL migration files that create the conversations table, add conversation_id FK to chat_messages, and backfill all existing messages into default conversations.
  </what-built>
  <how-to-verify>
Run these three migrations IN ORDER in the Supabase SQL Editor (https://supabase.com/dashboard):

1. Open SQL Editor
2. Paste and run `supabase/migrations/20260208120000_conversations_table.sql`
   - Expected: "Success. No rows returned" (table created)
3. Paste and run `supabase/migrations/20260208120100_chat_messages_conversation_fk.sql`
   - Expected: "Success. No rows returned" (column + FK added)
4. Paste and run `supabase/migrations/20260208120200_backfill_default_conversations.sql`
   - Expected: NOTICE messages showing migration statistics, ending with "Migration verification PASSED"

5. Run this verification query to confirm:
```sql
-- Check for orphaned messages (should be 0)
SELECT COUNT(*) AS orphaned FROM chat_messages WHERE conversation_id IS NULL;

-- Check each user has exactly one conversation
SELECT user_id, COUNT(*) AS conv_count
FROM conversations
GROUP BY user_id
HAVING COUNT(*) != 1;
-- Should return 0 rows

-- Check message-conversation user match
SELECT COUNT(*) AS mismatched
FROM chat_messages cm
JOIN conversations c ON cm.conversation_id = c.id
WHERE cm.user_id != c.user_id;
-- Should return 0
```

6. Go to the Table Editor in Supabase dashboard and verify:
   - `conversations` table exists with rows (one per user who had messages)
   - `chat_messages` table has a `conversation_id` column, all rows populated
  </how-to-verify>
  <resume-signal>Type "approved" if all migrations ran successfully and verification queries pass, or describe any errors.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `conversations` table exists with correct schema (5 columns, RLS, indexes, trigger)
2. `chat_messages.conversation_id` column exists with FK constraint (validated)
3. Zero orphaned messages (all have conversation_id)
4. Each user with messages has exactly one conversation titled "Chat History"
5. No message's user_id mismatches its conversation's user_id
6. Existing chat functionality still works (messages API returns data)
</verification>

<success_criteria>
- conversations table exists with id, user_id, title, created_at, updated_at and full RLS
- chat_messages has conversation_id UUID column with validated FK to conversations(id)
- Every existing chat message belongs to a backfilled default conversation
- Zero orphaned messages, zero user_id mismatches
- User querying conversations sees exactly one conversation containing all their prior messages
</success_criteria>

<output>
After completion, create `.planning/phases/08-db-schema-migration/08-01-SUMMARY.md`
</output>
