---
phase: 04-security-hardening
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/csrf.ts
  - app/chat/page.tsx
  - app/import/page.tsx
  - app/memory/page.tsx
  - app/dashboard/page.tsx
  - app/enter/page.tsx
  - app/test-upload/page.tsx
  - app/test-voice/page.tsx
  - components/access-code-modal.tsx
  - components/chat/telegram-chat-v2.tsx
  - lib/chunked-upload.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Client-side POST/PUT/DELETE requests include X-CSRF-Token header"
    - "CSRF token is fetched once per page load and reused across requests"
    - "Requests with valid CSRF token succeed (not rejected with 403)"
  artifacts:
    - path: "lib/csrf.ts"
      provides: "CSRF token fetching utility and csrfFetch wrapper"
      exports: ["getCsrfToken", "csrfFetch"]
  key_links:
    - from: "lib/csrf.ts"
      to: "middleware.ts"
      via: "X-CSRF-Token response header from GET requests"
      pattern: "X-CSRF-Token"
    - from: "app/chat/page.tsx"
      to: "lib/csrf.ts"
      via: "import getCsrfToken"
      pattern: "getCsrfToken|csrfFetch"
    - from: "app/import/page.tsx"
      to: "lib/csrf.ts"
      via: "import getCsrfToken"
      pattern: "getCsrfToken|csrfFetch"
---

<objective>
Close Gap 1 from verification: CSRF token flow is incomplete. The server-side CSRF middleware (middleware.ts) sets X-CSRF-Token on responses and validates it on POST/PUT/DELETE requests, but NO client-side code reads or sends the token. Without this, all state-changing requests will be rejected with 403 Forbidden in production.

Purpose: Complete the CSRF protection circuit so state-changing API calls actually work
Output: CSRF utility + all client-side fetch calls updated to include CSRF token
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-security-hardening/04-01-SUMMARY.md
@middleware.ts
@lib/retry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSRF token utility (lib/csrf.ts)</name>
  <files>lib/csrf.ts</files>
  <action>
Create a client-side CSRF utility at lib/csrf.ts with two exports:

1. `getCsrfToken(): Promise<string>` — Fetches the CSRF token by making a lightweight GET request to the app's own origin and reading the X-CSRF-Token response header. Cache the token in a module-level variable so subsequent calls return the cached value without a network request. The @edge-csrf/nextjs middleware sets X-CSRF-Token on every GET response.

Implementation:
```typescript
let cachedToken: string | null = null;

export async function getCsrfToken(): Promise<string> {
  if (cachedToken) return cachedToken;

  // Fetch from any page — middleware adds X-CSRF-Token to all GET responses
  const res = await fetch('/api/health/supabase', { method: 'GET' });
  const token = res.headers.get('X-CSRF-Token');
  if (token) {
    cachedToken = token;
    return token;
  }

  // Fallback: return empty string (middleware may be disabled in dev)
  console.warn('[CSRF] Could not obtain CSRF token');
  return '';
}
```

2. `csrfFetch(url: string, options?: RequestInit): Promise<Response>` — A thin wrapper around fetch that automatically adds the X-CSRF-Token header to POST/PUT/DELETE/PATCH requests. For GET/HEAD/OPTIONS, it passes through without modification.

Implementation:
```typescript
export async function csrfFetch(url: string, options?: RequestInit): Promise<Response> {
  const method = (options?.method || 'GET').toUpperCase();

  // Only state-changing methods need CSRF token
  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {
    const token = await getCsrfToken();
    const headers = new Headers(options?.headers);
    if (token) {
      headers.set('X-CSRF-Token', token);
    }
    return fetch(url, { ...options, headers });
  }

  return fetch(url, options);
}
```

Also export a `clearCsrfToken()` function that sets cachedToken = null, useful if the token expires or after logout.

IMPORTANT: Do NOT import from 'next/headers' — this is a client-side module. Only use browser-native fetch.
  </action>
  <verify>
Check the file exists and exports the three functions:
```bash
grep -n "export.*getCsrfToken\|export.*csrfFetch\|export.*clearCsrfToken" lib/csrf.ts
```
Verify it does NOT import from 'next/headers' or any server-only modules:
```bash
grep "next/headers" lib/csrf.ts  # Should return nothing
```
Run `npm run build` to verify no compilation errors.
  </verify>
  <done>lib/csrf.ts exists with getCsrfToken, csrfFetch, and clearCsrfToken exports. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CSRF token into all client-side fetch calls</name>
  <files>
    app/chat/page.tsx
    app/import/page.tsx
    app/memory/page.tsx
    app/dashboard/page.tsx
    app/enter/page.tsx
    app/test-upload/page.tsx
    app/test-voice/page.tsx
    components/access-code-modal.tsx
    components/chat/telegram-chat-v2.tsx
    lib/chunked-upload.ts
  </files>
  <action>
For each file that makes POST/PUT/DELETE fetch calls to our own API routes, add the CSRF token header.

**Strategy:** Import `getCsrfToken` from `@/lib/csrf` and add the token to the headers of each state-changing fetch call. Do NOT use the csrfFetch wrapper — that would require changing too many call signatures and interfere with existing patterns like fetchWithRetry. Instead, obtain the token and spread it into existing headers objects.

**For each file, apply this pattern:**

1. Add import at the top:
   ```typescript
   import { getCsrfToken } from '@/lib/csrf';
   ```

2. For each fetch call with method POST/PUT/DELETE/PATCH, add X-CSRF-Token to headers:
   ```typescript
   // Before:
   const res = await fetch('/api/endpoint', {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify(data),
   });

   // After:
   const csrfToken = await getCsrfToken();
   const res = await fetch('/api/endpoint', {
     method: 'POST',
     headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
     body: JSON.stringify(data),
   });
   ```

3. For FormData requests (no Content-Type header), add only the CSRF header:
   ```typescript
   // Before:
   const res = await fetch('/api/transcribe', {
     method: 'POST',
     body: formData,
   });

   // After:
   const csrfToken = await getCsrfToken();
   const res = await fetch('/api/transcribe', {
     method: 'POST',
     headers: { 'X-CSRF-Token': csrfToken },
     body: formData,
   });
   ```

4. For fetchWithRetry calls (in app/chat/page.tsx), same pattern — add to headers object:
   ```typescript
   const csrfToken = await getCsrfToken();
   const response = await fetchWithRetry('/api/chat/messages', {
     method: 'POST',
     headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
     body: JSON.stringify({ role, content }),
   });
   ```

**Files and their fetch calls to update:**

- **app/chat/page.tsx**: fetchWithRetry('/api/chat/messages'), fetch('/api/profile/ai-name') x3, fetch('/api/tasks'), fetch('/api/chat')
- **app/import/page.tsx**: fetch('/api/user/reset' DELETE), fetch('/api/import/queue-processing')
- **app/memory/page.tsx**: fetch('/api/memory/delete')
- **app/dashboard/page.tsx**: fetch('/api/profile/ai-name')
- **app/enter/page.tsx**: fetch('/api/waitlist')
- **app/test-upload/page.tsx**: fetch('/api/test-upload')
- **app/test-voice/page.tsx**: fetch('/api/transcribe')
- **components/access-code-modal.tsx**: fetch('/api/waitlist')
- **components/chat/telegram-chat-v2.tsx**: fetch('/api/transcribe')
- **lib/chunked-upload.ts**: fetch(uploadUrl) — this POSTs to /api/import/chunked-upload

**Do NOT modify these (server-to-server calls, not browser fetch):**
- lib/mem0/client.ts (calls external Mem0 API, not our routes)
- lib/motia-client.ts (calls external Motia API)
- lib/search/perplexity.ts (calls external Perplexity API)
- Any fetch calls inside app/api/ route handlers (server-side)

**Performance note:** getCsrfToken caches after first call, so multiple calls in the same page are cheap (no network). The first call costs one GET request.

**Optimization:** In files with many fetch calls (app/chat/page.tsx has ~6), get the token once at the top of the calling function rather than calling getCsrfToken() before each fetch. The function returns a cached value so it's fine either way, but reads cleaner.
  </action>
  <verify>
Verify every client-side POST/PUT/DELETE fetch includes CSRF header:
```bash
# Should show X-CSRF-Token in all client files with POST/PUT/DELETE
grep -rn "X-CSRF-Token" app/chat/page.tsx app/import/page.tsx app/memory/page.tsx app/dashboard/page.tsx app/enter/page.tsx components/access-code-modal.tsx components/chat/telegram-chat-v2.tsx lib/chunked-upload.ts
```

Verify imports are present:
```bash
grep -rn "getCsrfToken" app/chat/page.tsx app/import/page.tsx app/memory/page.tsx app/dashboard/page.tsx app/enter/page.tsx components/access-code-modal.tsx components/chat/telegram-chat-v2.tsx lib/chunked-upload.ts
```

Run `npm run build` to verify no compilation errors.
  </verify>
  <done>All client-side POST/PUT/DELETE fetch calls include X-CSRF-Token header. Build passes. No server-side files modified.</done>
</task>

</tasks>

<verification>
1. `lib/csrf.ts` exists with getCsrfToken, csrfFetch, clearCsrfToken exports
2. Every client-side file that makes POST/PUT/DELETE requests imports getCsrfToken
3. Every client-side POST/PUT/DELETE fetch call includes 'X-CSRF-Token' in headers
4. No server-side files (app/api/, lib/mem0/, lib/motia-client.ts, lib/search/) were modified
5. `npm run build` passes without errors
6. No imports from 'next/headers' in lib/csrf.ts (it's client-side only)
</verification>

<success_criteria>
- Client-side CSRF utility exists and caches token after first fetch
- All ~15 client-side POST/PUT/DELETE fetch calls include X-CSRF-Token header
- Build passes without errors
- CSRF protection circuit is complete: middleware sets token -> client reads token -> client sends token -> middleware validates token
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-05-SUMMARY.md`
</output>
