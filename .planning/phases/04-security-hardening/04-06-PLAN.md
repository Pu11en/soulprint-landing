---
phase: 04-security-hardening
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/transcribe/route.ts
  - app/api/soulprint/generate/route.ts
  - app/api/embeddings/process/route.ts
  - app/api/memory/synthesize/route.ts
  - app/api/voice/process/route.ts
  - app/api/voice/enroll/route.ts
  - app/api/voice/verify/route.ts
  - app/api/voice/upload/route.ts
  - app/api/tasks/route.ts
  - app/api/branch/route.ts
  - app/api/profile/ai-name/route.ts
  - app/api/profile/ai-avatar/route.ts
  - app/api/memory/query/route.ts
  - app/api/memory/delete/route.ts
  - app/api/chat/messages/route.ts
  - app/api/chat/mem0/route.ts
  - app/api/waitlist/route.ts
  - app/api/auth/signout/route.ts
  - app/api/user/reset/route.ts
  - app/api/push/subscribe/route.ts
  - app/api/pillars/submit/route.ts
  - app/api/pillars/stories/route.ts
  - app/api/pillars/summaries/route.ts
  - app/api/import/complete/route.ts
  - app/api/import/queue-processing/route.ts
  - app/api/import/mem0/route.ts
  - app/api/import/motia/start/route.ts
  - app/api/gamification/xp/route.ts
  - app/api/gamification/achievements/notify/route.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All POST/PUT/DELETE API endpoints enforce per-user rate limits"
    - "Expensive AI/processing endpoints use the 'expensive' tier (20/min)"
    - "Standard CRUD endpoints use the 'standard' tier (60/min)"
    - "Rate-limited requests return 429 with Retry-After header"
  artifacts:
    - path: "app/api/transcribe/route.ts"
      provides: "Rate-limited audio transcription"
      contains: "checkRateLimit"
    - path: "app/api/soulprint/generate/route.ts"
      provides: "Rate-limited soulprint generation"
      contains: "checkRateLimit"
    - path: "app/api/tasks/route.ts"
      provides: "Rate-limited task operations"
      contains: "checkRateLimit"
  key_links:
    - from: "app/api/transcribe/route.ts"
      to: "lib/rate-limit.ts"
      via: "import checkRateLimit"
      pattern: "checkRateLimit.*expensive"
    - from: "app/api/tasks/route.ts"
      to: "lib/rate-limit.ts"
      via: "import checkRateLimit"
      pattern: "checkRateLimit.*standard"
---

<objective>
Close Gap 2 from verification: Rate limiting coverage is too low. Only 3 of ~35 POST/PUT/DELETE endpoints have rate limiting (9% coverage). The checkRateLimit utility already exists and works. This plan adds it to all remaining state-changing endpoints with appropriate tier classification.

Purpose: Prevent abuse of expensive AI operations and spam of standard CRUD endpoints
Output: All POST/PUT/DELETE endpoints rate-limited with appropriate tiers
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-security-hardening/04-02-SUMMARY.md
@lib/rate-limit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limiting to expensive AI/processing endpoints</name>
  <files>
    app/api/transcribe/route.ts
    app/api/soulprint/generate/route.ts
    app/api/embeddings/process/route.ts
    app/api/memory/synthesize/route.ts
    app/api/voice/process/route.ts
    app/api/voice/enroll/route.ts
    app/api/voice/verify/route.ts
    app/api/voice/upload/route.ts
    app/api/chat/mem0/route.ts
    app/api/import/mem0/route.ts
    app/api/import/queue-processing/route.ts
    app/api/import/motia/start/route.ts
  </files>
  <action>
Add `checkRateLimit` with the 'expensive' tier (20 req/min) to all AI-heavy and processing endpoints. These endpoints call external AI services (Bedrock, RLM, Whisper) or do significant compute.

**Tier: expensive (20/min)**

For each file, follow the exact same integration pattern used in app/api/chat/route.ts:

1. Add import at top of file:
   ```typescript
   import { checkRateLimit } from '@/lib/rate-limit';
   ```

2. Add rate limit check AFTER authentication (need user.id), BEFORE expensive processing:
   ```typescript
   // After getting the authenticated user...
   const rateLimited = await checkRateLimit(user.id, 'expensive');
   if (rateLimited) return rateLimited;
   // ...then proceed with expensive operation
   ```

**Endpoint-specific notes:**

- **app/api/transcribe/route.ts** — POST handler, expensive (Whisper audio transcription). Add after auth check.
- **app/api/soulprint/generate/route.ts** — POST handler, expensive (RLM soulprint generation). Add after auth check.
- **app/api/embeddings/process/route.ts** — POST handler, expensive (embedding generation). Add after auth check.
- **app/api/memory/synthesize/route.ts** — POST handler, expensive (AI memory synthesis). Add after auth check.
- **app/api/voice/process/route.ts** — POST handler, expensive (voice processing). Add after auth check.
- **app/api/voice/enroll/route.ts** — POST handler, expensive (voice enrollment). Add after auth check.
- **app/api/voice/verify/route.ts** — POST handler, expensive (voice verification). Add after auth check.
- **app/api/voice/upload/route.ts** — POST handler, expensive (voice upload + processing). Add after auth check.
- **app/api/chat/mem0/route.ts** — POST handler, expensive (AI chat via Mem0). Add after auth check.
- **app/api/import/mem0/route.ts** — POST handler, expensive (Mem0 import). Add after auth check.
- **app/api/import/queue-processing/route.ts** — POST handler, expensive (triggers import processing). Add after auth check.
- **app/api/import/motia/start/route.ts** — POST handler, expensive (starts Motia import). Add after auth check.

**IMPORTANT:** Some endpoints get user ID differently:
- Most use `supabase.auth.getUser()` -> `user.id`
- Some use `request.headers.get('X-Internal-User-Id')` for server-to-server calls
- For internal calls, skip rate limiting (same pattern as process-server/route.ts)
- If an endpoint doesn't have auth, find where it gets the user identifier and use that

**Do NOT modify these (already have rate limiting):**
- app/api/chat/route.ts (already has 'expensive')
- app/api/import/process-server/route.ts (already has 'expensive')
- app/api/import/chunked-upload/route.ts (already has 'upload')
  </action>
  <verify>
Verify all expensive endpoints now have rate limiting:
```bash
grep -l "checkRateLimit" app/api/transcribe/route.ts app/api/soulprint/generate/route.ts app/api/embeddings/process/route.ts app/api/memory/synthesize/route.ts app/api/voice/process/route.ts app/api/voice/enroll/route.ts app/api/voice/verify/route.ts app/api/voice/upload/route.ts app/api/chat/mem0/route.ts app/api/import/mem0/route.ts app/api/import/queue-processing/route.ts app/api/import/motia/start/route.ts
```
All 12 files should match. Verify tier is 'expensive':
```bash
grep -n "expensive" app/api/transcribe/route.ts app/api/soulprint/generate/route.ts app/api/embeddings/process/route.ts app/api/memory/synthesize/route.ts
```
Run `npm run build` to verify no compilation errors.
  </verify>
  <done>All 12 expensive/AI endpoints have checkRateLimit with 'expensive' tier. Build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add rate limiting to standard CRUD endpoints</name>
  <files>
    app/api/tasks/route.ts
    app/api/branch/route.ts
    app/api/profile/ai-name/route.ts
    app/api/profile/ai-avatar/route.ts
    app/api/memory/query/route.ts
    app/api/memory/delete/route.ts
    app/api/chat/messages/route.ts
    app/api/waitlist/route.ts
    app/api/auth/signout/route.ts
    app/api/user/reset/route.ts
    app/api/push/subscribe/route.ts
    app/api/pillars/submit/route.ts
    app/api/pillars/stories/route.ts
    app/api/pillars/summaries/route.ts
    app/api/import/complete/route.ts
    app/api/gamification/xp/route.ts
    app/api/gamification/achievements/notify/route.ts
  </files>
  <action>
Add `checkRateLimit` with the 'standard' tier (60 req/min) to all standard CRUD and lightweight endpoints.

**Tier: standard (60/min)**

Same integration pattern as Task 1 — import checkRateLimit, add after auth, before processing.

```typescript
import { checkRateLimit } from '@/lib/rate-limit';

// In POST/PUT/DELETE handler, after auth:
const rateLimited = await checkRateLimit(user.id, 'standard');
if (rateLimited) return rateLimited;
```

**Endpoints to update:**

- **app/api/tasks/route.ts** — Has both POST and DELETE handlers. Add rate limiting to BOTH. Use the same user.id for both.
- **app/api/branch/route.ts** — POST handler, standard (conversation branching).
- **app/api/profile/ai-name/route.ts** — POST handler, standard (rename AI). Already has Zod validation — add rate limit BEFORE validation.
- **app/api/profile/ai-avatar/route.ts** — POST handler. Note: this may do AI avatar generation; if it calls external AI services, use 'expensive' instead. Check the implementation. If it just saves a URL, use 'standard'.
- **app/api/memory/query/route.ts** — POST handler, standard (memory search). Already has Zod validation — add rate limit BEFORE validation.
- **app/api/memory/delete/route.ts** — POST handler, standard (memory deletion). Already has Zod validation — add rate limit BEFORE validation.
- **app/api/chat/messages/route.ts** — POST handler, standard (save message to DB). Already has Zod validation — add rate limit BEFORE validation.
- **app/api/waitlist/route.ts** — POST handler, standard (waitlist signup). Already has Zod validation — add rate limit BEFORE validation. Note: This endpoint may not have auth (public waitlist). If no user.id available, use email or IP as identifier with a comment explaining why.
- **app/api/auth/signout/route.ts** — POST handler, standard (logout).
- **app/api/user/reset/route.ts** — DELETE handler, standard (reset user data).
- **app/api/push/subscribe/route.ts** — Has POST and DELETE handlers. Add to BOTH.
- **app/api/pillars/submit/route.ts** — POST handler, standard (pillar submission).
- **app/api/pillars/stories/route.ts** — POST handler. Check if it calls AI — if so, use 'expensive'. If just DB query, use 'standard'.
- **app/api/pillars/summaries/route.ts** — POST handler. Check if it calls AI — if so, use 'expensive'. If just DB query, use 'standard'.
- **app/api/import/complete/route.ts** — POST handler, standard (marks import as done). Already has Zod validation — add rate limit BEFORE validation.
- **app/api/gamification/xp/route.ts** — POST handler, standard (add XP).
- **app/api/gamification/achievements/notify/route.ts** — POST handler, standard (achievement notifications).

**Endpoints to SKIP (admin/debug/test/cron — not user-facing):**
- app/api/admin/* (admin-only, protected by separate auth)
- app/api/debug/* (dev-only)
- app/api/test-* (test endpoints)
- app/api/cron/* (internal cron jobs)
- app/api/health/* (health checks, GET only)
- app/api/rlm/health/route.ts (GET only)
- app/api/chat/health/route.ts (GET only)
- app/api/chat/perplexity-health/route.ts (GET only)
- app/api/gamification/stats/route.ts (GET only)
- app/api/gamification/achievements/route.ts (GET only — check if it also has POST)
- app/api/memory/status/route.ts (GET only)
- app/api/memory/list/route.ts (GET only)
- app/api/import/motia/status/route.ts (GET only)
- app/api/waitlist/confirm/route.ts (GET-based confirmation link)

**IMPORTANT for endpoints without auth (waitlist, etc.):**
- If the endpoint is public (no Supabase auth), use a request identifier like the email from the request body or the IP address from `request.headers.get('x-forwarded-for')` as the rate limit key.
- Add a comment: `// Rate limit by IP — no auth available on public endpoint`

**IMPORTANT for ai-avatar and pillars endpoints:**
- Read the file first. If it calls external AI services (OpenAI, Bedrock, RLM), use 'expensive' tier instead of 'standard'.
  </action>
  <verify>
Verify all standard endpoints now have rate limiting:
```bash
grep -l "checkRateLimit" app/api/tasks/route.ts app/api/branch/route.ts app/api/profile/ai-name/route.ts app/api/profile/ai-avatar/route.ts app/api/memory/query/route.ts app/api/memory/delete/route.ts app/api/chat/messages/route.ts app/api/waitlist/route.ts app/api/auth/signout/route.ts app/api/user/reset/route.ts app/api/push/subscribe/route.ts app/api/pillars/submit/route.ts app/api/pillars/stories/route.ts app/api/pillars/summaries/route.ts app/api/import/complete/route.ts app/api/gamification/xp/route.ts app/api/gamification/achievements/notify/route.ts
```
All 17 files should match.

Count total rate-limited POST/PUT/DELETE endpoints (should be ~32):
```bash
grep -rl "checkRateLimit" app/api/ | wc -l
```

Run `npm run build` to verify no compilation errors.
  </verify>
  <done>All 17 standard CRUD endpoints have checkRateLimit. Combined with Task 1 (12) and existing (3), total is ~32 rate-limited endpoints. Build passes.</done>
</task>

</tasks>

<verification>
1. All expensive AI endpoints (12) have checkRateLimit with 'expensive' tier
2. All standard CRUD endpoints (17) have checkRateLimit with 'standard' tier
3. Previously rate-limited endpoints (3) are unchanged
4. Admin, debug, test, cron, and GET-only endpoints are intentionally skipped
5. Total rate-limited endpoints: ~32 out of ~35 POST/PUT/DELETE handlers
6. `npm run build` passes without errors
7. Rate limit check happens after auth but before processing in every endpoint
</verification>

<success_criteria>
- Rate limiting coverage goes from 9% (3/35) to >90% (32+/35)
- Expensive AI operations use 'expensive' tier (20/min)
- Standard CRUD operations use 'standard' tier (60/min)
- Upload operations (already done) use 'upload' tier (100/min)
- All rate-limited responses include 429 status + Retry-After header (provided by checkRateLimit utility)
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-security-hardening/04-06-SUMMARY.md`
</output>
