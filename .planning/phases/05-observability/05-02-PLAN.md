---
phase: 05-observability
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/api/health/route.ts
  - app/api/admin/health/route.ts
autonomous: true

must_haves:
  truths:
    - "Public /api/health endpoint returns JSON with overall status and per-dependency health"
    - "Health check reports 'degraded' when a non-critical dependency is unhealthy"
    - "Health check reports 'down' (HTTP 503) when a critical dependency is unreachable"
    - "Each dependency check has a 5-second timeout to prevent cascading failures"
    - "Bedrock check is config-only (credentials exist) — no actual AWS API call"
  artifacts:
    - path: "app/api/health/route.ts"
      provides: "Public unauthenticated health check endpoint"
      exports: ["GET"]
    - path: "app/api/admin/health/route.ts"
      provides: "Admin-only detailed health check with structured logging"
      contains: "createLogger"
  key_links:
    - from: "app/api/health/route.ts"
      to: "Supabase"
      via: "SELECT 1 query with 5s timeout"
      pattern: "checkSupabase"
    - from: "app/api/health/route.ts"
      to: "RLM service"
      via: "GET /health with 5s timeout"
      pattern: "checkRLM"
    - from: "app/api/health/route.ts"
      to: "Bedrock"
      via: "Environment variable presence check"
      pattern: "checkBedrock"
---

<objective>
Create a public health check endpoint with per-dependency status and degraded state detection.

Purpose: Enable load balancers and monitoring tools to assess application health without authentication. The endpoint checks Supabase, RLM, and Bedrock dependencies and returns an overall status (healthy/degraded/down) with per-dependency details. Also update the existing admin health endpoint to use structured logging.

Output: Public `/api/health` endpoint and updated `/api/admin/health` with Pino logging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-observability/05-RESEARCH.md

Key existing file:
@app/api/admin/health/route.ts

Depends on Plan 05-01 output:
@lib/logger/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public /api/health endpoint with dependency checks</name>
  <files>
    app/api/health/route.ts
  </files>
  <action>
    Create `app/api/health/route.ts` as a public, unauthenticated health check endpoint.

    1. Define TypeScript interfaces:
       ```typescript
       interface DependencyHealth {
         status: 'healthy' | 'degraded' | 'down'
         latency_ms: number
         message?: string
       }

       interface HealthResponse {
         status: 'healthy' | 'degraded' | 'down'
         timestamp: string
         dependencies: {
           supabase: DependencyHealth
           rlm: DependencyHealth
           bedrock: DependencyHealth
         }
       }
       ```

    2. Implement `checkSupabase()`:
       - Create admin Supabase client (same pattern as other routes: createClient with service role key)
       - Run `SELECT id FROM profiles LIMIT 1` with `AbortSignal.timeout(5000)`
       - If query succeeds: return `{ status: 'healthy', latency_ms, message: 'Connected' }`
       - If query errors but connection works: return `{ status: 'degraded', latency_ms, message: error.message }`
       - If connection fails or times out: return `{ status: 'down', latency_ms, message: 'Connection failed' }`

    3. Implement `checkRLM()`:
       - If `RLM_SERVICE_URL` env var not set: return `{ status: 'down', latency_ms: 0, message: 'Not configured' }`
       - Fetch `{RLM_SERVICE_URL}/health` with `AbortSignal.timeout(5000)`
       - If response OK: return `{ status: 'healthy', latency_ms, message: 'Responding' }`
       - If non-OK response: return `{ status: 'degraded', latency_ms, message: 'HTTP {status}' }`
       - If timeout or error: return `{ status: 'down', latency_ms, message: error.message }`

    4. Implement `checkBedrock()`:
       - Config-only check (do NOT make actual AWS API calls)
       - Check if `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `BEDROCK_MODEL_ID` env vars exist
       - If all present: return `{ status: 'healthy', latency_ms: 0, message: 'Configured' }`
       - If any missing: return `{ status: 'down', latency_ms: 0, message: 'Missing credentials' }`

    5. Implement GET handler:
       - Import `createLogger` from `@/lib/logger`
       - Create `const log = createLogger('Health')`
       - Run all three checks in parallel with `Promise.all`
       - Compute overall status: 'down' if any dependency down, 'degraded' if any degraded, 'healthy' otherwise
       - Log health check result: `log.info({ duration, status: overallStatus }, 'Health check completed')`
       - Return JSON with HTTP 503 if overall status is 'down', otherwise 200
       - Wrap in try/catch: on error, log and return 500

    6. This endpoint is PUBLIC — no auth check. It's designed for load balancers and monitoring.
       Do NOT add rate limiting here (health checks must always respond).
  </action>
  <verify>
    - `npm run build` succeeds
    - File `app/api/health/route.ts` exists and exports GET handler
    - `grep "AbortSignal.timeout(5000)" app/api/health/route.ts` confirms timeout on dependency checks
    - `grep "createLogger" app/api/health/route.ts` confirms structured logging
    - `grep -v "auth\|getUser" app/api/health/route.ts | head -5` confirms no auth check (public endpoint)
  </verify>
  <done>
    Public /api/health endpoint checks Supabase (query), RLM (HTTP), and Bedrock (config). Returns overall healthy/degraded/down status. Each check has 5-second timeout. No authentication required.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update admin health endpoint with structured logging</name>
  <files>
    app/api/admin/health/route.ts
  </files>
  <action>
    Update the existing `/api/admin/health/route.ts` to use structured Pino logging:

    1. Import `createLogger` from `@/lib/logger`
    2. Create `const log = createLogger('AdminHealth')`
    3. Replace `console.error('Health check error:', err)` with `log.error({ error: err, duration: Date.now() - startTime }, 'Admin health check failed')`
    4. Add request logging:
       - At handler start: `const startTime = Date.now()`
       - After auth check: `log.info({ userId: user.id }, 'Admin health check requested')`
       - After checks complete: `log.info({ duration: Date.now() - startTime, overall_status }, 'Admin health check completed')`
    5. Add `AbortSignal.timeout(5000)` to the RLM fetch call (currently uses manual AbortController with 10s timeout — modernize to 5s with AbortSignal.timeout)
    6. Add `AbortSignal.timeout(5000)` to the Supabase query (currently has no timeout)
    7. Keep the existing admin auth check and all service checks (Supabase, RLM, Perplexity)
    8. Keep the existing circuit breaker status reporting
  </action>
  <verify>
    - `npm run build` succeeds
    - `grep "createLogger" app/api/admin/health/route.ts` confirms structured logging
    - `grep -c "console\." app/api/admin/health/route.ts` returns 0 (all console calls replaced)
    - `grep "AbortSignal.timeout" app/api/admin/health/route.ts` confirms modernized timeouts
    - `npm test` passes
  </verify>
  <done>
    Admin health endpoint uses structured Pino logging. Console statements replaced. Dependency checks use 5-second AbortSignal.timeout instead of manual AbortController. Request lifecycle logged with duration.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. `npm test` passes (existing tests not broken)
3. Public `/api/health` endpoint exists and has no auth check
4. Public endpoint returns `{ status, timestamp, dependencies: { supabase, rlm, bedrock } }` JSON shape
5. Admin endpoint uses `createLogger` (no more console.error)
6. Both endpoints use `AbortSignal.timeout(5000)` on dependency checks
7. `grep -r "console\." app/api/health/route.ts app/api/admin/health/route.ts` returns NO matches
</verification>

<success_criteria>
- Public /api/health returns healthy/degraded/down based on Supabase, RLM, and Bedrock status
- Health check returns HTTP 503 when status is 'down', 200 otherwise
- Each dependency check has a 5-second timeout preventing cascading failures
- Bedrock check is config-only (no AWS API call)
- Admin health endpoint migrated to structured Pino logging
- Build succeeds and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability/05-02-SUMMARY.md`
</output>
