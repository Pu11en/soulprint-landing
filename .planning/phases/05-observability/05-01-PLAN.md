---
phase: 05-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/logger/index.ts
  - middleware.ts
  - lib/api/error-handler.ts
  - app/api/chat/route.ts
  - app/api/import/process-server/route.ts
  - app/api/import/chunked-upload/route.ts
  - app/api/memory/query/route.ts
autonomous: true

must_haves:
  truths:
    - "All API error responses include a correlation ID for request tracing"
    - "Structured JSON logs include correlation ID, user ID, endpoint, duration, and status code"
    - "Error handler uses Pino instead of console.error"
    - "Critical routes (chat, import, memory) log request start and completion with duration"
  artifacts:
    - path: "lib/logger/index.ts"
      provides: "Pino logger factory with environment-aware config and redaction"
      exports: ["logger", "createLogger"]
    - path: "middleware.ts"
      provides: "Correlation ID generation and header injection"
      contains: "x-correlation-id"
    - path: "lib/api/error-handler.ts"
      provides: "Structured error logging with Pino and correlation ID"
      contains: "createLogger"
  key_links:
    - from: "middleware.ts"
      to: "lib/api/error-handler.ts"
      via: "x-correlation-id request header"
      pattern: "x-correlation-id"
    - from: "lib/api/error-handler.ts"
      to: "lib/logger/index.ts"
      via: "import createLogger"
      pattern: "createLogger.*ErrorHandler"
    - from: "app/api/chat/route.ts"
      to: "lib/logger/index.ts"
      via: "import createLogger"
      pattern: "createLogger.*Chat"
---

<objective>
Implement structured logging with Pino and correlation ID tracking across all API routes.

Purpose: Replace ad-hoc console.log/error statements with structured JSON logging that includes correlation IDs for request tracing, enabling production debugging and performance monitoring. The centralized error handler already covers 14+ routes, so updating it provides broad coverage immediately.

Output: Logger factory module, correlation ID middleware injection, structured error handler, and request-level logging on the 4 most critical API routes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-observability/05-RESEARCH.md

Key existing files:
@middleware.ts
@lib/api/error-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pino, create logger factory, inject correlation ID in middleware</name>
  <files>
    package.json
    lib/logger/index.ts
    middleware.ts
  </files>
  <action>
    1. Install dependencies:
       ```bash
       npm install pino pino-pretty
       ```

    2. Create `lib/logger/index.ts` with Pino logger factory:
       - Production: JSON output, level 'info', formatters.level returns label string
       - Development: pino-pretty transport with colorize, translateTime 'HH:MM:ss', ignore 'pid,hostname'
       - Redact sensitive fields: req.headers.authorization, req.headers.cookie, password, token, apiKey, access_token, secret (remove: true)
       - Export `logger` (base Pino instance) and `createLogger(context: string)` which returns `logger.child({ context })`
       - Support LOG_LEVEL env var override in production (default 'info')

    3. Update `middleware.ts` to inject correlation ID:
       - Generate `correlationId` via `crypto.randomUUID()` at the top of the middleware function
       - Set `request.headers.set('x-correlation-id', correlationId)` before CSRF middleware runs
       - Set `authResponse.headers.set('x-correlation-id', correlationId)` on the response before returning
       - Do NOT import Pino in middleware (Edge runtime incompatible with Node.js Pino). The correlation ID is set via headers only.

    Important: Pino uses Node.js APIs and CANNOT run in Edge runtime. The middleware only sets headers. Route handlers (Node.js runtime) read the header and create Pino loggers.
  </action>
  <verify>
    - `npm run build` succeeds (no type errors, Edge runtime compatibility)
    - `lib/logger/index.ts` exists and exports `logger` and `createLogger`
    - `middleware.ts` sets `x-correlation-id` header on both request and response
    - `grep -r "x-correlation-id" middleware.ts` returns matches
  </verify>
  <done>
    Pino installed. Logger factory exports createLogger with env-aware config and redaction. Middleware injects crypto.randomUUID() correlation ID into request and response headers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate structured logging into error handler and critical routes</name>
  <files>
    lib/api/error-handler.ts
    app/api/chat/route.ts
    app/api/import/process-server/route.ts
    app/api/import/chunked-upload/route.ts
    app/api/memory/query/route.ts
  </files>
  <action>
    1. Update `lib/api/error-handler.ts`:
       - Import `createLogger` from `@/lib/logger`
       - Create module-level `const log = createLogger('ErrorHandler')`
       - Accept optional `correlationId` parameter: `handleAPIError(error: unknown, context: string, correlationId?: string)`
       - Replace `console.error(...)` with `log.error({ correlationId, context, error: ... }, 'API error occurred')`
       - For Error instances, log: `{ message: error.message, name: error.name, stack: (dev only) }`
       - Add correlationId to all returned APIErrorResponse JSON bodies (add to interface too)
       - Keep the existing status code logic (504 for TimeoutError, 500 for Error, 500 for unknown)

    2. Add request logging to `app/api/chat/route.ts` (POST handler):
       - Import `createLogger` from `@/lib/logger`
       - Create `const log = createLogger('API:Chat')`
       - At handler start: read `x-correlation-id` from request headers
       - Create child logger: `const reqLog = log.child({ correlationId, method: 'POST', endpoint: '/api/chat' })`
       - After auth: add userId to child: `reqLog.child({ userId: user.id })`
       - Record `startTime = Date.now()`
       - Log at start: `reqLog.info('Chat request started')`
       - Log at success: `reqLog.info({ duration: Date.now() - startTime, status: 200 }, 'Chat request completed')`
       - In catch: pass `correlationId` to `handleAPIError` if it's used, or log via reqLog
       - Replace existing `console.log`/`console.error` calls within the handler with structured log calls

    3. Add request logging to `app/api/import/process-server/route.ts` (POST handler):
       - Same pattern: createLogger('API:ImportProcessServer'), child with correlationId/userId
       - Log: request start, processing stages (parsing, chunking, soulprint generation), completion with duration
       - Replace console.log/error with structured equivalents

    4. Add request logging to `app/api/import/chunked-upload/route.ts` (POST handler):
       - Same pattern: createLogger('API:ChunkedUpload'), child with correlationId/userId
       - Log: upload start, chunk assembly, completion with duration

    5. Add request logging to `app/api/memory/query/route.ts` (POST handler):
       - Same pattern: createLogger('API:MemoryQuery'), child with correlationId/userId
       - Log: query start, search results count, completion with duration

    For all routes: Do NOT replace every console.log. Focus on:
    - Request entry (info level)
    - Request completion with duration and status (info level)
    - Errors (error level, via handleAPIError or direct)
    - Key decision points (debug level, only if already logged)

    Leave non-critical console.log statements for Phase 6+ cleanup. The goal is structured logging on the hot path, not 100% migration.
  </action>
  <verify>
    - `npm run build` succeeds
    - `grep -r "createLogger" lib/api/error-handler.ts app/api/chat/route.ts app/api/import/process-server/route.ts app/api/import/chunked-upload/route.ts app/api/memory/query/route.ts` shows imports in all 5 files
    - `grep "correlationId" lib/api/error-handler.ts` confirms it's used in error logging
    - `grep "duration" app/api/chat/route.ts` confirms duration tracking
    - `npm test` passes (no regression in existing tests)
  </verify>
  <done>
    Error handler uses Pino with correlation ID. Chat, import, chunked-upload, and memory-query routes have structured request logging with correlation ID, user ID, duration, and status code.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. `npm test` passes (existing tests not broken)
3. `grep -r "x-correlation-id" middleware.ts` returns matches for request and response header setting
4. `grep -r "createLogger" lib/logger/index.ts lib/api/error-handler.ts app/api/chat/route.ts app/api/import/process-server/route.ts` confirms structured logging integration
5. `grep -r "console.error" lib/api/error-handler.ts` returns NO matches (replaced with Pino)
6. Logger factory exports both `logger` and `createLogger`
</verification>

<success_criteria>
- Pino logger factory created with production JSON and dev pretty-print modes
- Sensitive fields (auth, cookies, passwords, tokens) redacted from all logs
- Correlation ID injected via middleware into every request
- Centralized error handler uses structured logging with correlation ID
- 4 critical API routes (chat, import-process, chunked-upload, memory-query) log request lifecycle with duration
- Build succeeds and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability/05-01-SUMMARY.md`
</output>
