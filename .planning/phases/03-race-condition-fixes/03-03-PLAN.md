---
phase: 03-race-condition-fixes
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - app/chat/page.tsx
autonomous: true

must_haves:
  truths:
    - "Memory status polling ignores out-of-order responses"
    - "Polling stops when component unmounts (no stale state updates)"
    - "All fetch calls in the chat page's polling useEffect use AbortController for cancellation"
    - "Initial data load fetches use AbortController cleanup"
  artifacts:
    - path: "app/chat/page.tsx"
      provides: "Sequence-tracked polling and AbortController on all fetches"
      contains: "latestRequestId"
  key_links:
    - from: "app/chat/page.tsx (polling useEffect)"
      to: "/api/memory/status"
      via: "fetch with AbortController + sequence tracking"
      pattern: "latestRequestId|requestId.*current"
    - from: "app/chat/page.tsx (load useEffect)"
      to: "/api/chat/messages"
      via: "fetch with AbortController cleanup"
      pattern: "controller\\.abort|signal.*controller"
---

<objective>
Fix polling race conditions with sequence tracking and add AbortController cancellation to all fetch calls in the chat page.

Purpose: BUG-04 fix -- the memory status polling in chat page can show stale data when a slow poll response arrives after a newer one (out-of-order). Additionally, fetch calls in useEffect hooks lack AbortController cleanup, causing potential state updates on unmounted components. This plan adds sequence tracking to polling and AbortController to all useEffect fetches.

Output: Race-condition-free polling with sequence numbers, and proper cleanup on all async operations in chat page.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-race-condition-fixes/03-RESEARCH.md
@.planning/phases/03-race-condition-fixes/03-02-SUMMARY.md

@app/chat/page.tsx
@app/api/memory/status/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sequence tracking to memory status polling</name>
  <files>app/chat/page.tsx</files>
  <action>
Rewrite the "Poll memory/embedding status" useEffect (the one with `setInterval(checkMemoryStatus, 5000)`) to use sequence tracking and AbortController:

1. Add a `useRef` for tracking the latest request ID:
   ```typescript
   const latestPollIdRef = useRef(0);
   ```

2. Rewrite the polling useEffect:
   ```typescript
   useEffect(() => {
     const controller = new AbortController();
     let pollSequence = 0;

     const checkMemoryStatus = async () => {
       const currentSeq = ++pollSequence;
       // Also update ref so other code can check latest
       latestPollIdRef.current = currentSeq;

       try {
         const res = await fetch('/api/memory/status', {
           signal: controller.signal
         });

         // Ignore if aborted or out-of-order
         if (controller.signal.aborted) return;
         if (currentSeq !== latestPollIdRef.current) {
           console.log(`[Memory] Ignoring stale poll response (seq ${currentSeq} != ${latestPollIdRef.current})`);
           return;
         }

         if (res.ok) {
           const data = await res.json();
           // ... existing state update logic (keep ALL the existing if/else logic for
           //     redirect to import, failed handling, processing, ready, etc.)
         }
       } catch (err) {
         if (err instanceof Error && err.name === 'AbortError') return;
         console.error('Memory status check failed:', err);
       }
     };

     checkMemoryStatus();
     const interval = setInterval(checkMemoryStatus, 5000);

     return () => {
       controller.abort();
       clearInterval(interval);
     };
   }, [router]);
   ```

3. Keep ALL the existing state update logic inside the `if (res.ok)` block exactly as-is (the redirect logic, failed handling, processing progress, embedding status checks). Only wrap it with the sequence check and abort check.

Key points:
- The `pollSequence` variable is local to the effect closure -- it increments on each call within the same effect lifecycle
- The `latestPollIdRef` is shared across effect lifecycles via useRef
- AbortController cancels in-flight fetch on unmount
- Stale responses (where a newer poll was initiated) are discarded
- AbortError is silently ignored (expected on cleanup)
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors. Grep for `latestPollIdRef` and `controller.abort` in the file to confirm the pattern is applied.
  </verify>
  <done>
Memory status polling uses sequence tracking to discard out-of-order responses. AbortController cancels in-flight requests on unmount. Stale responses never update state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AbortController to initial data load useEffect</name>
  <files>app/chat/page.tsx</files>
  <action>
Add AbortController cleanup to the "Load initial state" useEffect (the one with `loadChatState`):

1. Create an AbortController at the top of the useEffect:
   ```typescript
   useEffect(() => {
     const controller = new AbortController();

     const loadChatState = async () => {
       try {
         // ... existing auth check (no fetch, uses supabase client -- leave as-is)

         // Add signal to all fetch calls:
         const nameRes = await fetch('/api/profile/ai-name', { signal: controller.signal });
         // ... existing logic

         const avatarRes = await fetch('/api/profile/ai-avatar', { signal: controller.signal });
         // ... existing logic

         const historyRes = await fetch('/api/chat/messages?limit=100', { signal: controller.signal });
         // ... existing logic

       } catch (error) {
         // Add AbortError check before logging/handling
         if (error instanceof Error && error.name === 'AbortError') return;
         console.error('Failed to load chat state:', error);
         // ... existing error handling
       }
       setLoadingHistory(false);
     };

     loadChatState();

     return () => controller.abort();
   }, [router, aiName]);
   ```

2. For each existing fetch call inside `loadChatState`, add `{ signal: controller.signal }` (or merge with existing options if any).

3. Add AbortError early return in the catch block BEFORE the existing error handling.

4. Move `setLoadingHistory(false)` so it does NOT run on abort: wrap it with a guard `if (!controller.signal.aborted) setLoadingHistory(false);` or put it inside a finally block with that guard.

Do NOT change the logic inside each fetch handler (nameRes, avatarRes, historyRes processing). Only add signal passing and abort handling.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors. Run `npx vitest run` to confirm all tests pass. Grep for `controller.abort` appearing in both useEffect cleanup functions.
  </verify>
  <done>
All fetch calls in the chat page load useEffect pass AbortController signals. Component unmount cancels in-flight requests. No stale state updates on unmounted components. AbortError is silently handled.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. `npx vitest run` -- all existing tests pass
3. Memory polling useEffect has sequence tracking with `latestPollIdRef`
4. Memory polling useEffect has AbortController with cleanup
5. Initial load useEffect passes signal to all 3 fetch calls
6. Both useEffects return cleanup functions that call `controller.abort()`
7. AbortError is caught and silently ignored in both effects
</verification>

<success_criteria>
- Out-of-order polling responses are detected and discarded (sequence check)
- Component unmount cancels all in-flight fetch requests
- AbortError is handled gracefully (no error logs, no state updates)
- Polling interval is properly cleared on cleanup
- No "state update on unmounted component" warnings possible
- No regressions in build or existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-race-condition-fixes/03-03-SUMMARY.md`
</output>
