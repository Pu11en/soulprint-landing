---
phase: 03-race-condition-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/retry.ts
  - app/chat/page.tsx
autonomous: true

must_haves:
  truths:
    - "Failed message saves are retried up to 3 times with exponential backoff"
    - "User sees an error indicator when all retries are exhausted"
    - "AbortError (timeout/cancellation) is not retried"
    - "Successful retry clears any visible error state"
  artifacts:
    - path: "lib/retry.ts"
      provides: "Reusable fetchWithRetry utility"
      exports: ["fetchWithRetry"]
    - path: "app/chat/page.tsx"
      provides: "Message save uses retry, shows error indicator on failure"
      contains: "fetchWithRetry"
  key_links:
    - from: "app/chat/page.tsx"
      to: "lib/retry.ts"
      via: "import fetchWithRetry"
      pattern: "import.*fetchWithRetry.*from.*lib/retry"
    - from: "app/chat/page.tsx"
      to: "/api/chat/messages"
      via: "fetchWithRetry POST call"
      pattern: "fetchWithRetry.*api/chat/messages"
---

<objective>
Implement message save retry with exponential backoff and visible error indicator in the chat UI.

Purpose: BUG-03 fix -- when a chat message fails to save to the database (network error, server error), the save is retried with exponential backoff (2s, 4s, 8s + jitter). If all retries fail, the user sees an error indicator so they know their message history may be incomplete. Currently, save failures are silently logged to console with no retry and no user feedback.

Output: A reusable retry utility in `lib/retry.ts` and updated chat page that uses it for message saves with visible error state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-race-condition-fixes/03-RESEARCH.md

@app/chat/page.tsx
@app/api/chat/messages/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable fetchWithRetry utility</name>
  <files>lib/retry.ts</files>
  <action>
Create `lib/retry.ts` with a `fetchWithRetry` function. This utility wraps `fetch()` with exponential backoff retry logic. The function signature:

```typescript
export async function fetchWithRetry(
  url: string,
  options?: RequestInit,
  config?: { maxAttempts?: number; baseDelayMs?: number }
): Promise<Response>
```

Implementation details:
- Default maxAttempts: 3
- Default baseDelayMs: 1000
- Backoff formula: `2^attempt * baseDelayMs + random(0, 1000)` for jitter (per research)
  - Attempt 1 fails -> wait ~2s, Attempt 2 fails -> wait ~4s, Attempt 3 fails -> throw
- Do NOT retry on AbortError (check `err.name === 'AbortError'`) -- re-throw immediately
- Do NOT retry on HTTP 4xx responses (client errors are not transient) -- return the response as-is
- DO retry on HTTP 5xx responses (treat as transient server error)
- DO retry on network errors (TypeError from fetch)
- If all attempts exhausted, throw an Error with message: `Failed after ${maxAttempts} attempts`
- Log each retry attempt: `console.log(\`[Retry] Attempt ${attempt}/${maxAttempts} for ${url} after ${delay}ms\`)`

Add a 10s timeout per individual attempt using AbortSignal.timeout(10000) combined with any existing signal via AbortSignal.any() if the caller provides one. If AbortSignal.any is not available (check compatibility), fall back to just using AbortSignal.timeout(10000) when no caller signal is provided, or the caller's signal when one is provided (don't combine).

Also export the type for config:
```typescript
export interface RetryConfig {
  maxAttempts?: number;
  baseDelayMs?: number;
}
```
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors. Run `npx vitest run` to confirm no regressions.
  </verify>
  <done>
`lib/retry.ts` exports `fetchWithRetry` that retries failed fetches with exponential backoff + jitter, skips retry on AbortError and 4xx, retries on 5xx and network errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire retry into chat saveMessage with error indicator</name>
  <files>app/chat/page.tsx</files>
  <action>
Modify `app/chat/page.tsx` to use `fetchWithRetry` for message saves and show error UI on failure:

1. Import `fetchWithRetry` from `@/lib/retry`.

2. Add a `saveError` state:
   ```typescript
   const [saveError, setSaveError] = useState<string | null>(null);
   ```

3. Rewrite the `saveMessage` function to use `fetchWithRetry`:
   ```typescript
   const saveMessage = async (role: string, content: string) => {
     try {
       const response = await fetchWithRetry('/api/chat/messages', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ role, content }),
       });
       if (!response.ok) {
         console.error('[Chat] Failed to save message after retries:', response.status);
         setSaveError('Message may not have been saved. Check your connection.');
       } else {
         // Clear any previous save error on success
         if (saveError) setSaveError(null);
       }
     } catch (error) {
       console.error('[Chat] Message save failed after all retries:', error);
       setSaveError('Failed to save message. Your conversation may not be fully saved.');
     }
   };
   ```

4. Add a dismissable error banner in the JSX, right after the TelegramChatV2 component (inside the fragment, before the Memory Loading Indicator). When `saveError` is not null, show:
   ```jsx
   {saveError && (
     <div className="fixed bottom-20 left-1/2 -translate-x-1/2 z-40 max-w-sm w-full px-4">
       <div className="bg-red-500/10 backdrop-blur-sm border border-red-500/30 rounded-xl px-4 py-3 flex items-center gap-2">
         <span className="text-sm text-red-400 flex-1">{saveError}</span>
         <button
           onClick={() => setSaveError(null)}
           className="text-red-400/60 hover:text-red-400 text-xs font-medium shrink-0"
         >
           Dismiss
         </button>
       </div>
     </div>
   )}
   ```

5. The error auto-clears on next successful save (step 3 above handles this).

Do NOT change any other part of the chat page (message queue, processMessage, polling, UI structure). Only modify `saveMessage` and add the error banner.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors. Confirm `fetchWithRetry` is imported and used in saveMessage. Confirm saveError state and error banner exist in JSX.
  </verify>
  <done>
Chat message saves retry 3 times with exponential backoff on failure. User sees a dismissable red banner at bottom of screen when saves fail. Banner auto-clears on next successful save.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. `npx vitest run` -- all existing tests pass
3. `lib/retry.ts` exports fetchWithRetry with correct retry logic
4. `app/chat/page.tsx` uses fetchWithRetry in saveMessage function
5. Error banner renders when saveError is set
</verification>

<success_criteria>
- fetchWithRetry utility retries with 2^n * 1000ms + jitter delay
- AbortError is never retried
- HTTP 4xx responses are returned without retry
- HTTP 5xx and network errors trigger retry
- Chat page shows dismissable error indicator when message save fails after all retries
- Error indicator clears on next successful save
- No regressions in build or existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-race-condition-fixes/03-02-SUMMARY.md`
</output>
