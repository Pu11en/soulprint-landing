---
phase: 01-testing-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.mts
  - tests/setup.ts
  - tests/mocks/handlers.ts
  - tests/mocks/server.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "npm test command exists and runs Vitest"
    - "Vitest resolves @/* path aliases from tsconfig.json"
    - "MSW server starts and stops cleanly during test lifecycle"
    - "jest-dom matchers (toBeInTheDocument, etc.) are available in tests"
  artifacts:
    - path: "vitest.config.mts"
      provides: "Vitest configuration with jsdom, React plugin, tsconfig paths"
      contains: "defineConfig"
    - path: "tests/setup.ts"
      provides: "Global test setup with jest-dom matchers and MSW lifecycle"
      contains: "@testing-library/jest-dom/vitest"
    - path: "tests/mocks/server.ts"
      provides: "MSW server instance for test environment"
      contains: "setupServer"
    - path: "tests/mocks/handlers.ts"
      provides: "Default MSW request handlers for RLM and Supabase"
      contains: "http.post"
  key_links:
    - from: "vitest.config.mts"
      to: "tests/setup.ts"
      via: "setupFiles configuration"
      pattern: "setupFiles.*setup\\.ts"
    - from: "tests/setup.ts"
      to: "tests/mocks/server.ts"
      via: "import and lifecycle hooks"
      pattern: "server\\.listen|server\\.close"
    - from: "tests/mocks/server.ts"
      to: "tests/mocks/handlers.ts"
      via: "import handlers array"
      pattern: "setupServer\\(.*handlers"
---

<objective>
Install and configure the complete testing infrastructure: Vitest test runner, React Testing Library, and Mock Service Worker for API mocking.

Purpose: Establishes the test framework that all subsequent phases depend on for verifying bug fixes and hardening work.
Output: Working vitest.config.mts, test setup file, MSW mock infrastructure, and npm test script.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-foundation/01-RESEARCH.md
@tsconfig.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install test dependencies and add npm test script</name>
  <files>package.json</files>
  <action>
Install all testing dependencies as devDependencies:

```bash
npm install -D vitest @vitejs/plugin-react @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom msw vite-tsconfig-paths
```

Then add the test script to package.json scripts:

```json
"test": "vitest",
"test:run": "vitest run"
```

`test` runs Vitest in watch mode (for dev). `test:run` runs once and exits (for CI/verification).

Do NOT modify any existing scripts. Only add the two new test scripts.
  </action>
  <verify>
Run `npm test -- --run` (or `npx vitest run`) to confirm Vitest starts. It will report "no test files found" which is expected at this stage. The key verification is that it runs without configuration errors.
  </verify>
  <done>
npm test script exists. Vitest starts without errors. All 8 test packages installed in devDependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Vitest config, setup file, and MSW mock infrastructure</name>
  <files>
    vitest.config.mts
    tests/setup.ts
    tests/mocks/handlers.ts
    tests/mocks/server.ts
  </files>
  <action>
Create 4 files:

**vitest.config.mts** (project root):
```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tsconfigPaths from 'vite-tsconfig-paths'

export default defineConfig({
  plugins: [tsconfigPaths(), react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    exclude: ['node_modules', '.next', 'dist'],
  },
})
```

Key details:
- `tsconfigPaths()` MUST come before `react()` in plugins array (order matters for alias resolution)
- `environment: 'jsdom'` enables DOM APIs for React component testing
- `setupFiles` points to the setup file that configures jest-dom and MSW
- Exclude .next and dist to avoid scanning build artifacts

**tests/setup.ts**:
```typescript
import '@testing-library/jest-dom/vitest'
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from './mocks/server'

// Establish API mocking before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))

// Reset any request handlers added during tests back to defaults
afterEach(() => server.resetHandlers())

// Clean up after all tests are done
afterAll(() => server.close())
```

Key details:
- `onUnhandledRequest: 'error'` catches unhandled requests early (prevents silent failures)
- `resetHandlers()` in afterEach ensures test isolation
- Import `@testing-library/jest-dom/vitest` makes matchers like `toBeInTheDocument()` available globally

**tests/mocks/handlers.ts**:
```typescript
import { http, HttpResponse } from 'msw'

export const handlers = [
  // Mock RLM service health check
  http.get('https://soulprint-landing.onrender.com/health', () => {
    return HttpResponse.json({ status: 'ok' })
  }),

  // Mock RLM query endpoint
  http.post('https://soulprint-landing.onrender.com/query', async ({ request }) => {
    const body = await request.json() as Record<string, unknown>
    return HttpResponse.json({
      response: `Mocked response for: ${body.query || 'unknown'}`,
      memory_used: true,
    })
  }),

  // Mock RLM create-soulprint endpoint
  http.post('https://soulprint-landing.onrender.com/create-soulprint', () => {
    return HttpResponse.json({
      soulprint: 'Mocked soulprint text for testing',
      success: true,
    })
  }),
]
```

Key details:
- Only mock external services (RLM). Do NOT mock internal Next.js API routes here (those would be tested differently).
- Use the actual RLM_SERVICE_URL from CLAUDE.md so handlers match real fetch calls.
- Keep handlers minimal — individual tests can add/override handlers with `server.use()`.

**tests/mocks/server.ts**:
```typescript
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)
```

This is intentionally minimal — just instantiates the server with default handlers.
  </action>
  <verify>
Run `npx vitest run` — should still report "no test files found" but must NOT show any errors about config, setup file imports, or MSW initialization. Check that no import resolution errors appear.
  </verify>
  <done>
Four files created: vitest.config.mts, tests/setup.ts, tests/mocks/handlers.ts, tests/mocks/server.ts. Vitest starts cleanly with the configuration loaded. MSW server lifecycle hooks are registered.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` starts without errors (reports "no test files" is OK)
2. `cat package.json | grep -A2 '"test"'` shows both test scripts
3. All 4 config/setup files exist and have correct content
4. `ls node_modules/vitest node_modules/msw node_modules/@testing-library/react` confirms deps installed
</verification>

<success_criteria>
- Vitest runs with `npm test` command without configuration errors
- Path alias resolution configured via vite-tsconfig-paths
- MSW server configured with lifecycle hooks in setup file
- Default handlers exist for RLM service endpoints
- All 8 dev dependencies installed
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-foundation/01-01-SUMMARY.md`
</output>
