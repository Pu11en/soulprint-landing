---
phase: 01-testing-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/utils.test.ts
  - lib/gamification/xp.test.ts
autonomous: true

must_haves:
  truths:
    - "npm test runs and all tests pass with green output"
    - "cn() utility function is tested for class merging, conditional classes, and Tailwind deduplication"
    - "XP system calculateLevel and getLevelProgress are tested with known input/output pairs"
    - "Tests use @/* path aliases that resolve correctly"
  artifacts:
    - path: "lib/utils.test.ts"
      provides: "Unit tests for cn() class name utility"
      contains: "describe.*cn"
    - path: "lib/gamification/xp.test.ts"
      provides: "Unit tests for XP system calculations"
      contains: "describe.*XP"
  key_links:
    - from: "lib/utils.test.ts"
      to: "lib/utils.ts"
      via: "import cn function"
      pattern: "import.*cn.*from.*utils"
    - from: "lib/gamification/xp.test.ts"
      to: "lib/gamification/xp.ts"
      via: "import XP_CONFIG"
      pattern: "import.*XP_CONFIG.*from.*xp"
---

<objective>
Create sample passing tests for two critical utility modules: the cn() class merging function and the XP system calculations.

Purpose: Validates the entire test pipeline works end-to-end (Vitest config -> setup file -> path aliases -> test execution -> assertions). Having real passing tests confirms the infrastructure from Plan 01 is correctly wired.
Output: Two co-located test files with passing tests demonstrating utility and business logic testing patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-testing-foundation/01-RESEARCH.md
@.planning/phases/01-testing-foundation/01-01-SUMMARY.md
@lib/utils.ts
@lib/gamification/xp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cn() utility tests</name>
  <files>lib/utils.test.ts</files>
  <action>
Create `lib/utils.test.ts` co-located next to `lib/utils.ts`. This tests the `cn()` function which wraps clsx + tailwind-merge.

```typescript
import { describe, it, expect } from 'vitest'
import { cn } from '@/lib/utils'

describe('cn', () => {
  it('merges multiple class names', () => {
    expect(cn('px-2', 'py-1')).toBe('px-2 py-1')
  })

  it('handles conditional classes (false values excluded)', () => {
    expect(cn('base', false && 'hidden', 'visible')).toBe('base visible')
  })

  it('handles undefined and null values', () => {
    expect(cn('base', undefined, null, 'end')).toBe('base end')
  })

  it('deduplicates conflicting Tailwind classes (last wins)', () => {
    expect(cn('px-2', 'px-4')).toBe('px-4')
  })

  it('deduplicates conflicting color classes', () => {
    expect(cn('text-red-500', 'text-blue-500')).toBe('text-blue-500')
  })

  it('returns empty string for no arguments', () => {
    expect(cn()).toBe('')
  })

  it('handles array-style class names via clsx', () => {
    expect(cn(['px-2', 'py-1'])).toBe('px-2 py-1')
  })
})
```

Key details:
- Use `@/lib/utils` import (NOT relative `./utils`) to verify path alias resolution works.
- Tests cover: basic merging, conditional classes, null/undefined handling, Tailwind conflict resolution, empty input, array syntax.
- This is intentionally simple to serve as a "canary" test — if this fails, the infrastructure is broken.
  </action>
  <verify>Run `npx vitest run lib/utils.test.ts` — all tests should pass (7 tests, 0 failures).</verify>
  <done>lib/utils.test.ts exists with 7 passing tests covering cn() utility function. Path alias @/lib/utils resolves correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create XP system calculation tests</name>
  <files>lib/gamification/xp.test.ts</files>
  <action>
Create `lib/gamification/xp.test.ts` co-located next to `lib/gamification/xp.ts`. This tests the XP calculation business logic.

First, understand the XP system formulas from xp.ts:
- `getLevelThreshold(level)` = `Math.floor(level * 100 * (1 + level * 0.1))`
  - Level 1: floor(1 * 100 * 1.1) = 110
  - Level 2: floor(2 * 100 * 1.2) = 240
  - Level 3: floor(3 * 100 * 1.3) = 390
- `calculateLevel(totalXp)` iterates levels, summing thresholds until exceeded
  - 0 XP = Level 1 (haven't passed threshold of 110)
  - 109 XP = Level 1
  - 110 XP = Level 2 (exactly at threshold)
  - 350 XP = Level 2 (110 + 240 = 350, exactly at threshold for level 3)
  - 351 XP = Level 3
- `getLevelProgress(totalXp)` returns current XP in level, XP needed, percentage

```typescript
import { describe, it, expect } from 'vitest'
import { XP_CONFIG } from '@/lib/gamification/xp'

describe('XP System', () => {
  describe('getLevelThreshold', () => {
    it('returns 110 XP needed for level 1', () => {
      expect(XP_CONFIG.getLevelThreshold(1)).toBe(110)
    })

    it('returns 240 XP needed for level 2', () => {
      expect(XP_CONFIG.getLevelThreshold(2)).toBe(240)
    })

    it('returns 390 XP needed for level 3', () => {
      expect(XP_CONFIG.getLevelThreshold(3)).toBe(390)
    })

    it('increases threshold with each level', () => {
      const t1 = XP_CONFIG.getLevelThreshold(1)
      const t2 = XP_CONFIG.getLevelThreshold(2)
      const t3 = XP_CONFIG.getLevelThreshold(3)
      expect(t2).toBeGreaterThan(t1)
      expect(t3).toBeGreaterThan(t2)
    })
  })

  describe('calculateLevel', () => {
    it('returns level 1 for 0 XP', () => {
      expect(XP_CONFIG.calculateLevel(0)).toBe(1)
    })

    it('returns level 1 for 109 XP (just under threshold)', () => {
      expect(XP_CONFIG.calculateLevel(109)).toBe(1)
    })

    it('returns level 2 for 110 XP (exactly at level 1 threshold)', () => {
      expect(XP_CONFIG.calculateLevel(110)).toBe(2)
    })

    it('returns level 2 for 349 XP (under level 2 threshold)', () => {
      // Level 2 threshold is 240, so need 110 + 240 = 350 to reach level 3
      expect(XP_CONFIG.calculateLevel(349)).toBe(2)
    })

    it('returns level 3 for 350 XP (exactly at cumulative threshold)', () => {
      expect(XP_CONFIG.calculateLevel(350)).toBe(3)
    })

    it('handles large XP values without error', () => {
      const level = XP_CONFIG.calculateLevel(100000)
      expect(level).toBeGreaterThan(10)
    })
  })

  describe('getLevelProgress', () => {
    it('returns 0 current XP and 110 needed at 0 XP', () => {
      const progress = XP_CONFIG.getLevelProgress(0)
      expect(progress.current).toBe(0)
      expect(progress.needed).toBe(110)
      expect(progress.percentage).toBe(0)
    })

    it('returns correct progress at 50 XP (level 1)', () => {
      const progress = XP_CONFIG.getLevelProgress(50)
      expect(progress.current).toBe(50)
      expect(progress.needed).toBe(110)
      expect(progress.percentage).toBe(Math.floor((50 / 110) * 100))
    })

    it('resets current XP after leveling up', () => {
      // At 110 XP, should be level 2 with 0 current XP in that level
      const progress = XP_CONFIG.getLevelProgress(110)
      expect(progress.current).toBe(0)
      expect(progress.needed).toBe(240) // level 2 threshold
      expect(progress.percentage).toBe(0)
    })

    it('percentage is always between 0 and 100', () => {
      for (const xp of [0, 50, 110, 200, 500, 1000]) {
        const progress = XP_CONFIG.getLevelProgress(xp)
        expect(progress.percentage).toBeGreaterThanOrEqual(0)
        expect(progress.percentage).toBeLessThanOrEqual(100)
      }
    })
  })

  describe('action XP values', () => {
    it('has defined XP values for all actions', () => {
      expect(XP_CONFIG.actions.message_sent).toBe(10)
      expect(XP_CONFIG.actions.memory_created).toBe(25)
      expect(XP_CONFIG.actions.daily_login).toBe(15)
      expect(XP_CONFIG.actions.streak_bonus).toBe(5)
    })
  })
})
```

Key details:
- Use `@/lib/gamification/xp` import to verify path aliases work in subdirectories.
- Pre-calculated expected values from the formula to ensure correctness.
- Tests boundary conditions: 0 XP, just-under-threshold, exactly-at-threshold, large values.
- getLevelProgress tested for reset after level-up and percentage bounds.
- action XP values tested as snapshot to catch accidental changes.
  </action>
  <verify>Run `npx vitest run lib/gamification/xp.test.ts` — all tests should pass. Then run `npx vitest run` to confirm both test files pass together.</verify>
  <done>lib/gamification/xp.test.ts exists with passing tests covering getLevelThreshold, calculateLevel, getLevelProgress, and action XP values. Full test suite runs with `npm test` and all tests pass.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all tests pass (both files, all assertions green)
2. `npx vitest run --reporter=verbose` — shows individual test names for both describe blocks
3. Path aliases resolve: tests use `@/lib/utils` and `@/lib/gamification/xp` without errors
4. No TypeScript errors in test files
</verification>

<success_criteria>
- Both test files exist co-located with their source modules
- All tests pass when running `npm test -- --run` (or `npx vitest run`)
- Tests use @/* path aliases (not relative imports) to validate infrastructure
- cn() tests cover merging, conditionals, Tailwind deduplication
- XP tests cover level calculation with boundary conditions
- Test output shows green passing results with 0 failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-testing-foundation/01-02-SUMMARY.md`
</output>
