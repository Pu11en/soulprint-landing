---
phase: 06-prompt-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: false

must_haves:
  truths:
    - "tools_md column exists in user_profiles table"
    - "memory_md column exists in user_profiles table"
    - "full_pass_status column exists in user_profiles table with check constraint"
    - "full_pass_started_at, full_pass_completed_at, full_pass_error columns exist"
  artifacts: []
  key_links: []
---

<objective>
Execute the 3 pending database migrations in Supabase SQL Editor to ensure all section columns exist in production.

Purpose: Without these columns, the structured sections (tools_md, memory_md) and full pass tracking (full_pass_status) cannot be queried in production. This is INFRA-01.

Output: Production database has all required columns for 7-section prompt composition.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@supabase/migrations/20260201_soulprint_files.sql
@supabase/migrations/20260206_add_tools_md.sql
@supabase/migrations/20260207_full_pass_schema.sql
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <action>Execute 3 pending SQL migrations in Supabase SQL Editor</action>
  <instructions>
Run the following 3 migration files in ORDER in the Supabase SQL Editor (https://supabase.com/dashboard -> SQL Editor):

**Migration 1: `supabase/migrations/20260201_soulprint_files.sql`**
Adds: soul_md, identity_md, agents_md, user_md, memory_log, memory_log_date columns.
- Open Supabase SQL Editor
- Paste contents of `supabase/migrations/20260201_soulprint_files.sql`
- Click "Run"
- Verify: no errors (IF NOT EXISTS means it's safe to re-run)

**Migration 2: `supabase/migrations/20260206_add_tools_md.sql`**
Adds: tools_md column.
- Paste contents of `supabase/migrations/20260206_add_tools_md.sql`
- Click "Run"

**Migration 3: `supabase/migrations/20260207_full_pass_schema.sql`**
Adds: memory_md, full_pass_status (with check constraint), full_pass_started_at, full_pass_completed_at, full_pass_error columns.
- Paste contents of `supabase/migrations/20260207_full_pass_schema.sql`
- Click "Run"

**Verification query (run after all 3):**
```sql
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'user_profiles'
AND column_name IN ('soul_md', 'identity_md', 'user_md', 'agents_md', 'tools_md', 'memory_md', 'full_pass_status', 'full_pass_started_at', 'full_pass_completed_at', 'full_pass_error', 'memory_log', 'memory_log_date')
ORDER BY column_name;
```

Expected: 12 rows returned, all columns exist.
  </instructions>
  <resume-signal>Type "migrations complete" after running all 3 migrations and verifying columns exist</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Automated post-migration column verification</name>
  <files>(no files modified — reads from Supabase)</files>
  <action>
After the human confirms migrations are complete, run an automated verification script that queries Supabase to confirm all 12 expected columns exist.

Use the Supabase JS client (or a direct REST call) to verify columns:

```bash
# Use the Supabase REST API to check if columns exist by attempting a select
# This verifies the columns are accessible from the application layer, not just SQL Editor
npx tsx -e "
const { createClient } = require('@supabase/supabase-js');
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

async function verify() {
  // Select all expected columns — if any don't exist, this will error
  const { data, error } = await supabase
    .from('user_profiles')
    .select('soul_md, identity_md, user_md, agents_md, tools_md, memory_md, full_pass_status, full_pass_started_at, full_pass_completed_at, full_pass_error, memory_log, memory_log_date')
    .limit(1);

  if (error) {
    console.error('VERIFICATION FAILED:', error.message);
    process.exit(1);
  }
  console.log('VERIFICATION PASSED: All 12 columns accessible via Supabase client');
  process.exit(0);
}
verify();
"
```

If the above approach has import issues, alternatively:
1. Use `curl` to call the Supabase REST API directly with the service role key
2. Select from user_profiles with all 12 column names
3. Verify HTTP 200 response (not 400 with "column not found" error)

The key requirement: verify that all 12 columns are accessible from the APPLICATION layer (Supabase client), not just from the SQL Editor. This catches permissions/RLS issues too.
  </action>
  <verify>Script exits with code 0 and prints "VERIFICATION PASSED"</verify>
  <done>All 12 columns confirmed accessible via Supabase client. Migration verified at the application layer.</done>
</task>

</tasks>

<verification>
1. Human confirmed migrations ran without errors
2. Automated verification script exits 0 — all 12 columns accessible via Supabase client
3. No column-not-found errors when selecting all expected columns
</verification>

<success_criteria>
- All 12 columns exist in user_profiles table
- full_pass_status has check constraint limiting to: pending, processing, complete, failed
- No data loss (IF NOT EXISTS used for all ALTERs)
- Columns accessible via Supabase JS client (not just SQL Editor)
</success_criteria>

<output>
After completion, create `.planning/phases/06-prompt-foundation/06-04-SUMMARY.md`
</output>
