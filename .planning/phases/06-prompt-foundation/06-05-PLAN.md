---
phase: 06-prompt-foundation
plan: 05
type: execute
wave: 2
depends_on: ["06-01", "06-04"]
files_modified:
  - app/api/profile/ai-name/route.ts
  - app/chat/page.tsx
autonomous: true

must_haves:
  truths:
    - "Personalized greeting uses signature_greeting from IDENTITY section when available"
    - "ai-name API endpoint returns signatureGreeting alongside aiName"
    - "Chat page uses signatureGreeting for welcome message when available"
    - "Both aiName and signatureGreeting are captured as local variables before setting welcome message (no timing bug)"
  artifacts:
    - path: "app/api/profile/ai-name/route.ts"
      provides: "Returns ai_name + signature_greeting from identity_md"
      contains: "signature_greeting"
    - path: "app/chat/page.tsx"
      provides: "Personalized greeting from IDENTITY section"
      contains: "signatureGreeting"
  key_links:
    - from: "app/chat/page.tsx"
      to: "app/api/profile/ai-name/route.ts"
      via: "fetch /api/profile/ai-name"
      pattern: "signatureGreeting"
---

<objective>
Implement personalized greetings from the IDENTITY section: update the ai-name API to return signature_greeting, and update the chat page to use it for the welcome message.

Purpose: This covers AI identity requirements (IDENT-01, IDENT-02) — the chat greeting should feel personal, using the AI's actual signature greeting from the soulprint when available, not a generic "How can I help?"

Output: Updated ai-name API returning signatureGreeting, chat page using it for welcome message.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-prompt-foundation/06-01-SUMMARY.md
@app/api/profile/ai-name/route.ts
@app/chat/page.tsx
@.planning/research/FEATURES-CHAT-PERSONALIZATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ai-name API to return signatureGreeting</name>
  <files>app/api/profile/ai-name/route.ts</files>
  <action>
In the GET handler, expand the Supabase select to include `identity_md`:
```typescript
const { data: profile } = await adminSupabase
  .from('user_profiles')
  .select('ai_name, identity_md')
  .eq('user_id', user.id)
  .single();
```

Parse `signature_greeting` from `identity_md`:
```typescript
let signatureGreeting: string | null = null;
if (profile?.identity_md) {
  try {
    const identity = JSON.parse(profile.identity_md);
    const greeting = identity?.signature_greeting;
    if (typeof greeting === 'string' && greeting.trim() && greeting.toLowerCase() !== 'not enough data') {
      signatureGreeting = greeting.trim();
    }
  } catch {
    // JSON parse failed, leave as null
  }
}
```

Return it in the response:
```typescript
return NextResponse.json({
  aiName: profile?.ai_name || null,
  hasName: !!profile?.ai_name,
  signatureGreeting,
});
```
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. Manual check: ai-name route.ts returns signatureGreeting in response
  </verify>
  <done>
- ai-name GET endpoint selects identity_md from DB
- Parses signature_greeting from identity_md JSON
- Returns signatureGreeting in API response (null if not available or "not enough data")
  </done>
</task>

<task type="auto">
  <name>Task 2: Update chat page to use signatureGreeting for welcome message</name>
  <files>app/chat/page.tsx</files>
  <action>
**CRITICAL: Fix the timing issue by capturing BOTH aiName and signatureGreeting as local variables in the same async function scope BEFORE setting messages.**

In the loadChatState function (or wherever ai-name is fetched), use LOCAL variables for both values:

```typescript
// Inside the async function that fetches ai-name:
let localAiName: string | null = null;
let localGreeting: string | null = null;

if (nameRes.ok) {
  const nameData = await nameRes.json();
  localAiName = nameData.aiName || null;
  localGreeting = nameData.signatureGreeting || null;

  // Update state for other uses
  if (localAiName) {
    setAiName(localAiName);
  }
}

// ... later when setting welcome message, use LOCAL variables (not state):
setMessages([{
  id: 'welcome',
  role: 'assistant',
  content: localGreeting
    ? localGreeting
    : `Hey! I'm ${localAiName || 'your AI'}. I've got your memories loaded. What's on your mind?`,
  timestamp: new Date(),
}]);
```

**WHY local variables:** React state updates (setAiName, etc.) are asynchronous — the updated values are NOT available until the next render. Using `aiName` state in the same function that calls `setAiName` will read the OLD value. By capturing `localAiName` and `localGreeting` as local variables in the same scope, both are guaranteed to be available when constructing the welcome message.

**Do NOT:**
- Use `signatureGreeting` state variable in the welcome message construction (timing bug)
- Use `aiName` state variable in the welcome message construction (timing bug)
- Add a separate useEffect to react to signatureGreeting changes (over-engineered)

**Optionally** add signatureGreeting to component state for potential future use elsewhere:
```typescript
const [signatureGreeting, setSignatureGreeting] = useState<string | null>(null);
// ... in the fetch handler:
if (localGreeting) setSignatureGreeting(localGreeting);
```
But the welcome message MUST use the local variable, not state.
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npx vitest run` — existing tests pass
3. Manual review: welcome message uses `localGreeting` and `localAiName` (local vars), NOT `signatureGreeting`/`aiName` (state)
  </verify>
  <done>
- Chat page fetches signatureGreeting from ai-name API
- Welcome message uses signatureGreeting when available
- Falls back to generic greeting with AI name if signatureGreeting not available
- No timing issues: both aiName and greeting captured as local variables in same async scope
- TypeScript compiles, existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npx vitest run` — all existing tests pass
3. Grep check: `grep -r "signatureGreeting" app/api/profile/ai-name/route.ts app/chat/page.tsx` — found in both
4. Grep check: `grep "localAiName\|localGreeting" app/chat/page.tsx` — found (using local variables for welcome message)
5. Manual check: welcome message construction does NOT reference `aiName` state variable directly
</verification>

<success_criteria>
- ai-name API returns signatureGreeting from identity_md
- Chat page welcome message uses signatureGreeting when available
- Falls back to generic greeting with AI name
- No timing bugs: uses local variables, not React state, for welcome message construction
- All existing tests pass
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-prompt-foundation/06-05-SUMMARY.md`
</output>
