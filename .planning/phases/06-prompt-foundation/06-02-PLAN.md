---
phase: 06-prompt-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/api/chat/route.ts
  - app/chat/page.tsx
  - app/api/profile/ai-name/route.ts
autonomous: true

must_haves:
  truths:
    - "buildSystemPrompt() uses cleanSection() before formatting to remove all placeholder text"
    - "buildSystemPrompt() uses formatSection() from prompt-helpers.ts for all 5 JSON sections"
    - "System prompt includes explicit memory context instructions telling AI to reference chunks naturally"
    - "System prompt includes explicit list of banned chatbot cliche phrases"
    - "AI name is injected naturally in the base prompt (already done, verify preserved)"
    - "Personalized greeting uses signature_greeting from IDENTITY section when available"
    - "ai-name API endpoint returns signatureGreeting alongside aiName"
    - "Chat page uses signatureGreeting for welcome message when available"
  artifacts:
    - path: "app/api/chat/route.ts"
      provides: "Updated buildSystemPrompt with cleanSection + formatSection + memory instructions + anti-generic"
      contains: "cleanSection"
    - path: "app/chat/page.tsx"
      provides: "Personalized greeting from IDENTITY section"
      contains: "signatureGreeting"
    - path: "app/api/profile/ai-name/route.ts"
      provides: "Returns ai_name + signature_greeting from identity_md"
      contains: "signature_greeting"
  key_links:
    - from: "app/api/chat/route.ts"
      to: "lib/soulprint/prompt-helpers.ts"
      via: "import cleanSection, formatSection"
      pattern: "import.*prompt-helpers"
    - from: "app/chat/page.tsx"
      to: "app/api/profile/ai-name/route.ts"
      via: "fetch /api/profile/ai-name"
      pattern: "signatureGreeting"
---

<objective>
Update the Next.js chat prompt builder to use the new section helpers (cleanSection + formatSection), add memory context instructions and anti-generic language, and implement personalized greetings from the IDENTITY section.

Purpose: This plan covers the Next.js side of prompt consistency (PROMPT-01, PROMPT-03, PROMPT-04), memory usage instructions (MEM-01), AI identity (IDENT-01, IDENT-02), and section validation in the prompt path (MEM-02 applied).

Output: Updated `buildSystemPrompt()` using new helpers, enhanced system prompt with memory + anti-generic instructions, personalized chat greeting from `signature_greeting`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-prompt-foundation/06-01-SUMMARY.md
@lib/soulprint/prompt-helpers.ts
@app/api/chat/route.ts
@app/chat/page.tsx
@app/api/profile/ai-name/route.ts
@.planning/research/FEATURES-CHAT-PERSONALIZATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update buildSystemPrompt() with new helpers + memory/anti-generic instructions</name>
  <files>app/api/chat/route.ts</files>
  <action>
**Import changes (top of file):**
Replace the `sectionToMarkdown` import with:
```typescript
import { cleanSection, formatSection } from '@/lib/soulprint/prompt-helpers';
```
Keep `sectionToMarkdown` import ONLY if it's used elsewhere in the file (check first). If only used in buildSystemPrompt, remove it.

**Update buildSystemPrompt() function (lines ~472-602):**

1. **Replace section parsing + composition block (lines ~513-564):**
   Instead of calling `sectionToMarkdown()` on raw parsed sections, call `cleanSection()` first, then `formatSection()`:

   ```typescript
   // Parse and clean structured sections
   const soul = cleanSection(parseSectionSafe(profile.soul_md));
   const identity = cleanSection(parseSectionSafe(profile.identity_md));
   const userInfo = cleanSection(parseSectionSafe(profile.user_md));
   const agents = cleanSection(parseSectionSafe(profile.agents_md));
   const tools = cleanSection(parseSectionSafe(profile.tools_md));
   const memorySection = profile.memory_md || null;

   const hasStructuredSections = soul || identity || userInfo || agents || tools;

   if (hasStructuredSections) {
     const soulMd = formatSection('Communication Style & Personality', soul);
     const identityMd = formatSection('Your AI Identity', identity);
     const userMd = formatSection('About This Person', userInfo);
     const agentsMd = formatSection('How You Operate', agents);
     const toolsMd = formatSection('Your Capabilities', tools);

     if (soulMd) prompt += `\n\n${soulMd}`;
     if (identityMd) prompt += `\n\n${identityMd}`;
     if (userMd) prompt += `\n\n${userMd}`;
     if (agentsMd) prompt += `\n\n${agentsMd}`;
     if (toolsMd) prompt += `\n\n${toolsMd}`;
     if (memorySection) prompt += `\n\n## MEMORY\n${memorySection}`;

     // Daily memory (unchanged)
     if (dailyMemory && dailyMemory.length > 0) { ... }
   } else if (profile.soulprint_text) {
     prompt += `\n\n## ABOUT THIS PERSON\n${profile.soulprint_text}`;
   }
   ```

2. **Enhance the base prompt (lines ~526-538) with expanded anti-generic + memory instructions:**
   Keep the existing OpenClaw-inspired intro. After the personality injection paragraph, ADD these explicit instructions:

   ```
   ## IMPORTANT BEHAVIORAL RULES

   NEVER use these phrases or anything similar:
   - "Great question!"
   - "I'd be happy to help!"
   - "That's a great point!"
   - "Certainly!"
   - "Absolutely!"
   - "How can I assist you today?"
   - "Is there anything else I can help with?"
   - "I'm here to help!"
   - "Let me help you with that!"
   - "Thank you for sharing!"

   When conversation context or memories are provided below, reference them naturally as if recalling something from a previous conversation — "Like we talked about...", "You mentioned...", "Remember when you..." — not "According to the retrieved context..." or "Based on available information...". These are YOUR memories of conversations you've had together.

   If SOUL or AGENTS sections define how you should communicate — follow them. They describe who you ARE, not suggestions. Embody the personality traits, tone, and style defined there.
   ```

   Place this AFTER the base prompt paragraph and BEFORE the sections. This ensures both Next.js fallback and any future paths include these rules.

3. **Keep all other logic unchanged:**
   - IMPOSTER MODE block stays
   - Web search results block stays
   - Memory context block stays
   - Daily memory block stays

**Do NOT change:**
- The section parsing at lines 310-323 (pre-RLM parsing) — that's for passing to RLM, not for local prompt building
- The tryRLMService call signature
- Any other function in the file
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npx vitest run` — existing tests still pass
3. Manual review: buildSystemPrompt no longer references sectionToMarkdown (unless used elsewhere)
  </verify>
  <done>
- buildSystemPrompt uses cleanSection + formatSection from prompt-helpers.ts
- System prompt includes expanded anti-generic banned phrases list
- System prompt includes memory context usage instructions
- No "not enough data" can appear in prompt output
- TypeScript compiles, existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add personalized greeting from IDENTITY section</name>
  <files>app/api/profile/ai-name/route.ts, app/chat/page.tsx</files>
  <action>
**Update ai-name API (app/api/profile/ai-name/route.ts):**

In the GET handler, expand the Supabase select to include `identity_md`:
```typescript
const { data: profile } = await adminSupabase
  .from('user_profiles')
  .select('ai_name, identity_md')
  .eq('user_id', user.id)
  .single();
```

Parse `signature_greeting` from `identity_md`:
```typescript
let signatureGreeting: string | null = null;
if (profile?.identity_md) {
  try {
    const identity = JSON.parse(profile.identity_md);
    const greeting = identity?.signature_greeting;
    if (typeof greeting === 'string' && greeting.trim() && greeting.toLowerCase() !== 'not enough data') {
      signatureGreeting = greeting.trim();
    }
  } catch {
    // JSON parse failed, leave as null
  }
}
```

Return it in the response:
```typescript
return NextResponse.json({
  aiName: profile?.ai_name || null,
  hasName: !!profile?.ai_name,
  signatureGreeting,
});
```

**Update chat page (app/chat/page.tsx):**

1. Add state for signature greeting:
```typescript
const [signatureGreeting, setSignatureGreeting] = useState<string | null>(null);
```

2. In the loadChatState function where it fetches ai-name (around line 63-70), capture the greeting:
```typescript
if (nameRes.ok) {
  const nameData = await nameRes.json();
  if (nameData.aiName) {
    setAiName(nameData.aiName);
  }
  if (nameData.signatureGreeting) {
    setSignatureGreeting(nameData.signatureGreeting);
  }
}
```

3. Update the welcome message (around line 93-98) to use signature greeting when available:
```typescript
setMessages([{
  id: 'welcome',
  role: 'assistant',
  content: signatureGreeting
    ? `${signatureGreeting}`
    : `Hey! I'm ${aiName}. I've got your memories loaded. What's on your mind?`,
  timestamp: new Date(),
}]);
```

**IMPORTANT:** There's a timing issue — `signatureGreeting` state may not be set yet when the welcome message is constructed. Solve this by using a local variable instead of state:

In the loadChatState function, use a local `greeting` variable:
```typescript
let greeting: string | null = null;
if (nameRes.ok) {
  const nameData = await nameRes.json();
  if (nameData.aiName) setAiName(nameData.aiName);
  greeting = nameData.signatureGreeting || null;
}

// ... later when setting welcome message:
content: greeting || `Hey! I'm ${aiName}. I've got your memories loaded. What's on your mind?`,
```

This ensures the greeting is available synchronously within the same function scope.
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npx vitest run` — existing tests pass
3. Manual check: ai-name route.ts returns signatureGreeting in response
4. Manual check: chat page.tsx uses greeting variable for welcome message
  </verify>
  <done>
- ai-name GET endpoint returns signatureGreeting parsed from identity_md
- Chat page uses signatureGreeting for welcome message when available
- Falls back to generic greeting if signatureGreeting not available
- No timing issues with state (uses local variable in async function)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero type errors
2. `npx vitest run` — all existing tests pass
3. Grep check: `grep -r "not enough data" app/api/chat/route.ts` — NOT found in prompt composition
4. Grep check: `grep -r "cleanSection\|formatSection" app/api/chat/route.ts` — found (using new helpers)
5. Grep check: `grep -r "signatureGreeting" app/api/profile/ai-name/route.ts app/chat/page.tsx` — found in both
6. Grep check: `grep "NEVER use these phrases" app/api/chat/route.ts` — found (anti-generic instructions)
7. Grep check: `grep "Like we talked about\|You mentioned\|Remember when" app/api/chat/route.ts` — found (memory instructions)
</verification>

<success_criteria>
- buildSystemPrompt calls cleanSection before formatSection for all 5 JSON sections
- System prompt contains expanded banned phrases list (10+ specific phrases)
- System prompt instructs natural memory referencing
- ai-name API returns signatureGreeting from identity_md
- Chat page welcome message uses signatureGreeting when available
- All existing tests pass
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-prompt-foundation/06-02-SUMMARY.md`
</output>
