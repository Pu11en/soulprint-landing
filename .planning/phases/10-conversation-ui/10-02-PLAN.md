---
phase: 10-conversation-ui
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - components/chat/conversation-sidebar.tsx
  - components/chat/conversation-item.tsx
  - components/chat/delete-confirmation.tsx
  - app/chat/page.tsx
autonomous: false

must_haves:
  truths:
    - "User sees a sidebar listing all conversations ordered by most recent activity"
    - "User can create a new conversation and immediately start chatting in it"
    - "User can click a conversation in the sidebar and its messages load in the chat area"
    - "User can delete a conversation with confirmation dialog and it disappears from sidebar"
    - "User can rename a conversation by editing its title inline in the sidebar"
    - "New conversations auto-generate a title after the first AI response"
    - "Sidebar is a drawer on mobile (hidden by default), persistent on desktop (md+ breakpoint)"
    - "Deleting the active conversation switches to the most recent remaining or creates a new one"
  artifacts:
    - path: "components/chat/conversation-sidebar.tsx"
      provides: "Responsive sidebar with conversation list, new chat button, mobile drawer"
      min_lines: 80
    - path: "components/chat/conversation-item.tsx"
      provides: "Single conversation list item with inline rename, delete trigger, active state"
      min_lines: 50
    - path: "components/chat/delete-confirmation.tsx"
      provides: "Accessible delete confirmation dialog using shadcn/ui Dialog"
      min_lines: 30
    - path: "app/chat/page.tsx"
      provides: "Full multi-conversation chat page with sidebar integration"
      min_lines: 200
  key_links:
    - from: "app/chat/page.tsx"
      to: "/api/conversations"
      via: "fetch in useEffect for conversation list"
      pattern: "fetch.*api/conversations"
    - from: "app/chat/page.tsx"
      to: "/api/chat/messages"
      via: "fetch with conversation_id param"
      pattern: "conversation_id"
    - from: "app/chat/page.tsx"
      to: "/api/conversations/[id]/title"
      via: "fire-and-forget after first AI response"
      pattern: "api/conversations.*title"
    - from: "components/chat/conversation-sidebar.tsx"
      to: "app/chat/page.tsx"
      via: "callback props (onCreate, onSelect, onDelete, onRename)"
      pattern: "onSelect|onCreate|onDelete|onRename"
    - from: "app/chat/page.tsx"
      to: "components/chat/conversation-sidebar.tsx"
      via: "conversations state passed as prop"
      pattern: "conversations="
---

<objective>
Build the frontend conversation management UI: responsive sidebar component with conversation list, inline rename, delete confirmation, and integrate everything into the chat page with full conversation switching, creation, and auto-title generation.

Purpose: This plan delivers the user-facing experience for Phase 10. Users will see and interact with a sidebar to manage multiple conversations, switching between them seamlessly with optimistic UI updates.

Output: Three new React components and a significantly updated chat page that supports multi-conversation workflow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-conversation-ui/10-RESEARCH.md
@.planning/phases/10-conversation-ui/10-01-SUMMARY.md
@app/chat/page.tsx
@components/chat/telegram-chat-v2.tsx
@components/ui/dialog.tsx
@lib/csrf.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sidebar components (conversation-sidebar, conversation-item, delete-confirmation)</name>
  <files>
    components/chat/conversation-sidebar.tsx
    components/chat/conversation-item.tsx
    components/chat/delete-confirmation.tsx
  </files>
  <action>
Create three new React components. All must use theme-aware Tailwind classes (bg-background, bg-card, text-foreground, text-muted-foreground, border-border, bg-primary, bg-muted, bg-accent, etc.) -- NO hardcoded colors.

**components/chat/delete-confirmation.tsx:**

A reusable delete confirmation dialog using the existing shadcn/ui Dialog component.

Props:
- `open: boolean` - dialog open state
- `onOpenChange: (open: boolean) => void` - dialog state callback
- `conversationTitle: string` - title of conversation being deleted (shown in dialog)
- `onConfirm: () => void` - called when user confirms delete
- `isDeleting: boolean` - disables button during async delete

Structure:
- Import Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter from '@/components/ui/dialog'
- Warning text: "This will permanently delete '{conversationTitle}' and all its messages. This action cannot be undone."
- Two buttons: Cancel (secondary, calls onOpenChange(false)) and Delete (destructive red bg, calls onConfirm)
- Cancel button: `bg-muted text-foreground border border-border hover:bg-accent`
- Delete button: `bg-red-500 text-white hover:bg-red-600 disabled:opacity-50`

**components/chat/conversation-item.tsx:**

A single conversation list item with inline editing capability.

Props:
- `id: string`
- `title: string`
- `isActive: boolean` - highlights when this is the current conversation
- `updatedAt: string` - ISO date string for relative time display
- `onSelect: (id: string) => void`
- `onRename: (id: string, newTitle: string) => void`
- `onDelete: (id: string) => void`

State:
- `isEditing: boolean` - inline edit mode
- `editValue: string` - current edit input value

Behavior:
- Normal mode: Clicking the item calls `onSelect(id)`. Title is displayed with `truncate` (single line ellipsis).
- Active state: Use `bg-accent` background when isActive is true, otherwise `hover:bg-muted`
- Show edit (Pencil icon) and delete (Trash2 icon) buttons on hover OR when active. Use `opacity-0 group-hover:opacity-100` pattern.
- Clicking edit icon: Enter edit mode (isEditing=true, editValue=title, auto-focus input)
- Edit mode: Show an input field instead of title span. On Enter key or blur: call `onRename(id, editValue.trim())` if changed, then exit edit mode. On Escape: revert and exit edit mode.
- Clicking delete icon: Call `onDelete(id)` (parent handles confirmation dialog)
- Show relative time (e.g., "2m ago", "1h ago", "Yesterday") computed from updatedAt. Use a simple helper function in the same file that formats relative time.
- Icons: Import Pencil and Trash2 from lucide-react. Size: w-4 h-4.
- Stop propagation on edit/delete button clicks so they don't trigger onSelect.
- IMPORTANT: Use `'use client'` directive at top.

**components/chat/conversation-sidebar.tsx:**

The main responsive sidebar component.

Props:
- `conversations: Array<{ id: string; title: string; created_at: string; updated_at: string }>`
- `activeConversationId: string | null`
- `isOpen: boolean` - mobile drawer open state
- `onClose: () => void` - close mobile drawer
- `onSelect: (id: string) => void`
- `onCreateNew: () => void`
- `onRename: (id: string, newTitle: string) => void`
- `onDelete: (id: string) => void`

Structure:
```
<aside> wrapper:
  - Fixed positioning on mobile (fixed inset-y-0 left-0 z-40 w-72)
  - Static on desktop (md:static md:w-72)
  - Transform for slide animation: translate-x-0 when open, -translate-x-full when closed
  - On desktop (md:), always translate-x-0
  - bg-card border-r border-border
  - Flex column layout: header, scrollable list, footer

  Header:
    - "Conversations" title (text-sm font-semibold text-muted-foreground uppercase tracking-wide)
    - "New Chat" button (Plus icon + "New Chat" text)
    - Button styling: w-full flex items-center gap-2 px-3 py-2 rounded-lg bg-primary text-primary-foreground hover:bg-primary/90
    - On click: calls onCreateNew() then onClose() (close drawer on mobile)

  Scrollable list:
    - flex-1 overflow-y-auto
    - Map conversations to ConversationItem components
    - Pass all callbacks through

  Delete confirmation:
    - Render DeleteConfirmation dialog (state managed here)
    - When ConversationItem calls onDelete, set deleteTargetId and open dialog
    - On confirm: call props.onDelete(deleteTargetId), close dialog
    - On cancel: close dialog
```

Mobile backdrop:
- When isOpen is true on mobile, render a backdrop div: `fixed inset-0 bg-black/50 z-30 md:hidden`
- Clicking backdrop calls onClose()

Transitions:
- Sidebar: `transition-transform duration-300 ease-in-out`
- Use the top offset to account for the header (the chat page will set this via CSS)

IMPORTANT: The sidebar must sit BELOW the chat header (the TelegramChatV2 header is fixed at top z-50). Set sidebar top to account for the 52px header + safe-area-inset-top. Use: `top: calc(52px + env(safe-area-inset-top, 0px))` and corresponding bottom for safe area.

Import icons: Plus from lucide-react.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to verify no type errors. Verify all three files exist:
- `ls components/chat/conversation-sidebar.tsx`
- `ls components/chat/conversation-item.tsx`
- `ls components/chat/delete-confirmation.tsx`
  </verify>
  <done>
Three new components created: ConversationSidebar (responsive drawer/sidebar with conversation list and new chat button), ConversationItem (inline rename, delete trigger, active state, relative time), DeleteConfirmation (accessible shadcn dialog with destructive action). All use theme-aware Tailwind classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate sidebar into chat page with multi-conversation state management</name>
  <files>app/chat/page.tsx</files>
  <action>
Major update to app/chat/page.tsx. This is the most complex task -- it wires the sidebar into the existing chat page and adds conversation lifecycle management.

**New state variables to add:**
```typescript
const [conversations, setConversations] = useState<Conversation[]>([]);
const [currentConversationId, setCurrentConversationId] = useState<string | null>(null);
const [sidebarOpen, setSidebarOpen] = useState(false);
const [isCreatingConversation, setIsCreatingConversation] = useState(false);
```

**New type:**
```typescript
type Conversation = {
  id: string;
  title: string;
  created_at: string;
  updated_at: string;
};
```

**Changes to loadChatState useEffect:**

After auth check, BEFORE loading messages:
1. Fetch conversation list: `GET /api/conversations`
2. If conversations exist:
   - Set conversations state
   - Set currentConversationId to the first one (most recent by updated_at)
   - Fetch messages for that conversation: `GET /api/chat/messages?conversation_id={id}&limit=100`
3. If NO conversations exist (edge case: new user who somehow got past import):
   - Create a new conversation: `POST /api/conversations` with title "New Chat"
   - Set it as current
   - Show welcome message (existing logic)

**Changes to saveMessage function:**

The saveMessage function currently sends `{ role, content }`. Update it to include `conversation_id: currentConversationId`. This requires currentConversationId to be available in the closure.

IMPORTANT: Because saveMessage is used inside processMessage (which is a useCallback), and currentConversationId changes, you need to handle the closure carefully. Pass currentConversationId explicitly to saveMessage or use a ref:
```typescript
const currentConversationIdRef = useRef<string | null>(null);
// Keep ref in sync
useEffect(() => {
  currentConversationIdRef.current = currentConversationId;
}, [currentConversationId]);
```
Then in saveMessage: `conversation_id: currentConversationIdRef.current`

**Conversation switching (handleSelectConversation):**
```typescript
const handleSelectConversation = useCallback(async (conversationId: string) => {
  // Abort any in-flight message requests
  abortControllerRef.current?.abort();
  abortControllerRef.current = null;
  setIsGenerating(false);

  // Immediately clear messages and set new conversation
  setMessages([]);
  setCurrentConversationId(conversationId);
  setSidebarOpen(false); // Close mobile drawer

  // Fetch messages for the selected conversation
  try {
    const res = await fetch(`/api/chat/messages?conversation_id=${conversationId}&limit=100`);
    if (res.ok) {
      const data = await res.json();
      setMessages(data.messages?.map((m: Message) => ({
        ...m,
        timestamp: new Date(m.created_at || Date.now()),
      })) || []);
    }
  } catch (error) {
    console.error('Failed to load conversation messages:', error);
  }
}, []);
```

**Create new conversation (handleCreateConversation):**
```typescript
const handleCreateConversation = useCallback(async () => {
  setIsCreatingConversation(true);
  try {
    const csrfToken = await getCsrfToken();
    const res = await fetch('/api/conversations', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
      body: JSON.stringify({ title: 'New Chat' }),
    });
    if (res.ok) {
      const { conversation } = await res.json();
      setConversations(prev => [conversation, ...prev]);
      setCurrentConversationId(conversation.id);
      setMessages([]); // Clear messages for new conversation
      setSidebarOpen(false);
    }
  } catch (error) {
    console.error('Failed to create conversation:', error);
  }
  setIsCreatingConversation(false);
}, []);
```

**Rename conversation (handleRenameConversation):**
```typescript
const handleRenameConversation = useCallback(async (id: string, newTitle: string) => {
  // Optimistic update
  setConversations(prev => prev.map(c => c.id === id ? { ...c, title: newTitle } : c));
  try {
    const csrfToken = await getCsrfToken();
    const res = await fetch(`/api/conversations/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
      body: JSON.stringify({ title: newTitle }),
    });
    if (!res.ok) {
      // Revert on failure - refetch conversation list
      const listRes = await fetch('/api/conversations');
      if (listRes.ok) {
        const data = await listRes.json();
        setConversations(data.conversations);
      }
    }
  } catch (error) {
    console.error('Failed to rename conversation:', error);
  }
}, []);
```

**Delete conversation (handleDeleteConversation):**
```typescript
const handleDeleteConversation = useCallback(async (id: string) => {
  const isActive = id === currentConversationIdRef.current;

  // Optimistic removal
  setConversations(prev => {
    const remaining = prev.filter(c => c.id !== id);
    if (isActive && remaining.length > 0) {
      // Switch to most recent remaining
      handleSelectConversation(remaining[0].id);
    } else if (isActive && remaining.length === 0) {
      // No conversations left - create new one
      handleCreateConversation();
    }
    return remaining;
  });

  try {
    const csrfToken = await getCsrfToken();
    await fetch(`/api/conversations/${id}`, {
      method: 'DELETE',
      headers: { 'X-CSRF-Token': csrfToken },
    });
  } catch (error) {
    console.error('Failed to delete conversation:', error);
  }
}, [handleSelectConversation, handleCreateConversation]);
```

**Auto-title generation:**

After the first complete AI response in processMessage's finally block, check if this is the first exchange (conversation title is "New Chat" and this is the first AI response). If so, fire-and-forget the title generation:

```typescript
// In processMessage's finally block, after saving the AI response:
if (responseContent) {
  saveMessage('assistant', responseContent);

  // Auto-generate title if this is the first exchange in a "New Chat" conversation
  const currentConv = conversations.find(c => c.id === currentConversationIdRef.current);
  if (currentConv?.title === 'New Chat' && messages.length <= 2) {
    // Fire and forget - don't await, don't block chat
    const convId = currentConversationIdRef.current;
    if (convId) {
      const csrfToken = await getCsrfToken();
      fetch(`/api/conversations/${convId}/title`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken },
        body: JSON.stringify({
          userMessage: content.slice(0, 1000),
          aiMessage: responseContent.slice(0, 1000),
        }),
      })
        .then(res => res.ok ? res.json() : null)
        .then(data => {
          if (data?.title) {
            setConversations(prev =>
              prev.map(c => c.id === convId ? { ...c, title: data.title } : c)
            );
          }
        })
        .catch(err => console.error('Title generation failed:', err));
    }
  }
}
```

IMPORTANT: The `conversations` variable reference in the auto-title check will be stale in the useCallback. Use a ref for conversations too, or use the functional update pattern. Simplest approach: check conversations state via ref.

**Layout change:**

Replace the current full-screen layout with a sidebar + chat layout:

```tsx
return (
  <>
    <div className="fixed inset-0 h-screen w-screen flex">
      {/* Sidebar */}
      <ConversationSidebar
        conversations={conversations}
        activeConversationId={currentConversationId}
        isOpen={sidebarOpen}
        onClose={() => setSidebarOpen(false)}
        onSelect={handleSelectConversation}
        onCreateNew={handleCreateConversation}
        onRename={handleRenameConversation}
        onDelete={handleDeleteConversation}
      />

      {/* Main chat area */}
      <div className="flex-1 relative">
        <TelegramChatV2
          messages={messages}
          onSendMessage={handleSendMessage}
          isLoading={isLoading}
          isGenerating={isGenerating}
          isDeepSearching={isDeepSearching}
          aiName={aiName}
          aiAvatar={aiAvatar || undefined}
          onBack={handleBack}
          onSettings={() => setShowSettings(true)}
          onStop={handleStop}
        />
      </div>
    </div>
    {/* ... rest of modals and overlays ... */}
  </>
);
```

**Hamburger menu button in TelegramChatV2:**

The TelegramChatV2 component needs a way to open the sidebar. Two options:
1. Add an `onMenuClick` prop to TelegramChatV2 and render a Menu icon button in the header
2. Add the menu button in the chat page layout instead

Option 1 is cleaner. Update TelegramChatV2Props to accept an optional `onMenuClick?: () => void` prop. In the header, REPLACE the existing Back button (ArrowLeft) with a conditional:
- If onMenuClick is provided: show Menu (hamburger) icon button that calls onMenuClick
- If onBack is provided and no onMenuClick: show Back button (existing behavior)

Actually, simpler approach: Add `onMenuClick` prop. In the header left section, show Menu icon if onMenuClick is provided, show Back button otherwise. Import `Menu` from lucide-react.

In chat page, pass `onMenuClick={() => setSidebarOpen(true)}` to TelegramChatV2.

**Files to import in chat page:**
```typescript
import { ConversationSidebar } from '@/components/chat/conversation-sidebar';
```

**Key constraint - conversation_id required for sending messages:**
The updated saveMessage schema requires conversation_id. If currentConversationId is null (briefly during initialization), messages should NOT be sent. Add a guard in handleSendMessage:
```typescript
if (!currentConversationIdRef.current) {
  console.error('No active conversation');
  return;
}
```

**Remove the dependency on `aiName` in the loadChatState useEffect:**
Currently the useEffect has `[router, aiName]` as dependencies which causes re-fetches when aiName changes. The conversations loading should only happen once. Change dependencies to `[router]` and handle aiName separately if needed.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to verify no type errors. Run `npm run build 2>&1 | tail -20` to verify build succeeds. Check that the chat page imports ConversationSidebar: `grep -n 'ConversationSidebar' app/chat/page.tsx`
  </verify>
  <done>
Chat page fully supports multi-conversation workflow: sidebar displays conversation list, users can create/switch/rename/delete conversations, auto-title fires after first exchange, conversation switching clears and reloads messages with AbortController cancellation, hamburger menu opens sidebar on mobile. All CSRF tokens included on mutations.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete conversation management UI with responsive sidebar, CRUD operations, inline rename, delete confirmation, auto-title generation, and conversation switching.</what-built>
  <how-to-verify>
1. Run `npm run dev` and open http://localhost:3000/chat
2. **Sidebar visibility:** On desktop (>768px), sidebar should be visible on the left with your existing "Chat History" conversation listed. On mobile (<768px), tap the hamburger menu icon to open the sidebar drawer.
3. **Create new conversation:** Click "New Chat" button in sidebar. A new conversation should appear at the top of the list. The chat area should be empty (ready for new messages).
4. **Send a message in new conversation:** Type a message and send. After the AI responds, the conversation title should auto-update from "New Chat" to a generated title (may take 2-3 seconds).
5. **Switch conversations:** Click the original "Chat History" conversation. Its messages should load in the chat area. Click back to the new conversation -- its messages should appear.
6. **Rename:** Click the pencil icon on a conversation. Edit the title inline, press Enter. Title should update.
7. **Delete:** Click the trash icon on a conversation. A confirmation dialog should appear. Click Delete. The conversation should disappear. If it was the active one, the app should switch to the next available conversation.
8. **Mobile drawer:** Resize to mobile width. The sidebar should be hidden. Tap the hamburger menu -- sidebar should slide in as a drawer with backdrop. Tapping the backdrop should close it.
9. **Theme:** Verify sidebar looks correct in both light and dark mode (toggle theme).
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. Three new component files exist in components/chat/
4. Chat page renders sidebar with conversation list
5. Full CRUD lifecycle works: create, switch, rename, delete
6. Auto-title fires after first AI response
7. Mobile responsive: drawer on small screens, persistent sidebar on desktop
8. All mutations include CSRF token
9. Conversation switching cancels in-flight requests and clears messages before loading new ones
</verification>

<success_criteria>
- User sees a responsive sidebar listing all conversations ordered by most recent activity
- User can create, switch between, rename, and delete conversations
- New conversations auto-generate titles from the first exchange (fire-and-forget, non-blocking)
- Deleting the active conversation auto-switches to the next available or creates a new one
- Sidebar is a slide-in drawer on mobile (<768px), persistent panel on desktop
- Delete confirmation uses accessible shadcn Dialog component
- All theme-aware styling (no hardcoded colors)
- No race conditions: AbortController on switch, guard on null conversationId
</success_criteria>

<output>
After completion, create `.planning/phases/10-conversation-ui/10-02-SUMMARY.md`
</output>
