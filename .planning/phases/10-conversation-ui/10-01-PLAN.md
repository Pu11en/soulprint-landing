---
phase: 10-conversation-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/api/schemas.ts
  - app/api/conversations/route.ts
  - app/api/conversations/[id]/route.ts
  - app/api/conversations/[id]/title/route.ts
  - app/api/chat/messages/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/conversations returns user's conversations ordered by updated_at DESC"
    - "POST /api/conversations creates a new conversation and returns it"
    - "PATCH /api/conversations/[id] renames a conversation"
    - "DELETE /api/conversations/[id] deletes a conversation and its messages (CASCADE)"
    - "POST /api/conversations/[id]/title auto-generates a title from first exchange"
    - "GET /api/chat/messages?conversation_id=X returns only that conversation's messages"
    - "POST /api/chat/messages with conversation_id saves message to correct conversation"
  artifacts:
    - path: "lib/api/schemas.ts"
      provides: "Zod schemas for conversation operations"
      contains: "createConversationSchema"
    - path: "app/api/conversations/route.ts"
      provides: "GET list and POST create endpoints"
      exports: ["GET", "POST"]
    - path: "app/api/conversations/[id]/route.ts"
      provides: "PATCH rename and DELETE endpoints"
      exports: ["PATCH", "DELETE"]
    - path: "app/api/conversations/[id]/title/route.ts"
      provides: "POST auto-title generation endpoint"
      exports: ["POST"]
    - path: "app/api/chat/messages/route.ts"
      provides: "Updated GET with conversation_id filter, POST with conversation_id insert"
  key_links:
    - from: "app/api/conversations/route.ts"
      to: "supabase conversations table"
      via: "adminSupabase.from('conversations')"
      pattern: "from\\('conversations'\\)"
    - from: "app/api/chat/messages/route.ts"
      to: "conversation_id column"
      via: "eq filter and insert field"
      pattern: "conversation_id"
    - from: "app/api/conversations/[id]/title/route.ts"
      to: "Bedrock AI"
      via: "ConverseCommand for title generation"
      pattern: "ConverseCommand"
---

<objective>
Create the backend API layer for conversation management: CRUD endpoints for conversations, auto-title generation, and update the existing messages API to support conversation_id filtering and insertion.

Purpose: The frontend sidebar (Plan 02) needs these API endpoints to list, create, rename, delete conversations and load conversation-specific messages. Without this backend, the UI has nothing to call.

Output: Five API route files and updated Zod schemas that fully support multi-conversation operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-conversation-ui/10-RESEARCH.md
@.planning/phases/08-db-schema-migration/08-01-SUMMARY.md
@lib/api/schemas.ts
@lib/api/error-handler.ts
@lib/csrf.ts
@lib/rate-limit.ts
@app/api/chat/messages/route.ts
@app/api/chat/route.ts
@supabase/migrations/20260208120000_conversations_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conversation Zod schemas and update saveMessageSchema</name>
  <files>lib/api/schemas.ts</files>
  <action>
Add a new "Conversation Schemas" section to lib/api/schemas.ts with these schemas:

1. `createConversationSchema`:
   - title: z.string().min(1).max(200).optional().default('New Chat')

2. `updateConversationSchema`:
   - title: z.string().min(1, 'Title is required').max(200, 'Title too long').trim()

3. `generateTitleSchema`:
   - userMessage: z.string().min(1).max(1000)
   - aiMessage: z.string().min(1).max(1000)

4. Update the existing `saveMessageSchema` to add conversation_id:
   - conversation_id: z.string().uuid('Invalid conversation ID')
   - This makes conversation_id REQUIRED on message saves (the frontend must always provide it)

Place the Conversation Schemas section right after the Chat Schemas section. Export all new schemas.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to verify no type errors. Grep for `createConversationSchema` in lib/api/schemas.ts to confirm export.
  </verify>
  <done>
Four new Zod schemas exported from lib/api/schemas.ts. saveMessageSchema includes conversation_id as required UUID field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conversation CRUD API routes</name>
  <files>
    app/api/conversations/route.ts
    app/api/conversations/[id]/route.ts
  </files>
  <action>
Create two API route files following the exact patterns from app/api/chat/messages/route.ts:

**app/api/conversations/route.ts** (GET + POST):

GET handler:
- Auth check via createClient() + getUser()
- Use getSupabaseAdmin() for data access (same pattern as messages route)
- Query: `adminSupabase.from('conversations').select('id, title, created_at, updated_at').eq('user_id', user.id).order('updated_at', { ascending: false }).limit(50)`
- Return: `{ conversations: conversations || [] }`
- Error handling: handleAPIError(error, 'API:Conversations:GET')

POST handler:
- Auth check
- Rate limit check: `checkRateLimit(user.id, 'standard')`
- Parse body with `parseRequestBody(request, createConversationSchema)`
- Insert: `adminSupabase.from('conversations').insert({ user_id: user.id, title }).select().single()`
- Return 201: `{ conversation }`
- Error handling: handleAPIError(error, 'API:Conversations:POST')

**app/api/conversations/[id]/route.ts** (PATCH + DELETE):

PATCH handler (rename):
- Auth check
- Rate limit: standard
- Parse body with `parseRequestBody(request, updateConversationSchema)`
- Extract `id` from `params` (Next.js dynamic route: `const { id } = await params`)
- Update: `adminSupabase.from('conversations').update({ title }).eq('id', id).eq('user_id', user.id).select().single()`
- The double `.eq()` ensures users can only rename their own conversations
- Return: `{ conversation }`
- Error handling: handleAPIError(error, 'API:Conversations:PATCH')

DELETE handler:
- Auth check
- Rate limit: standard
- Extract `id` from params
- Delete: `adminSupabase.from('conversations').delete().eq('id', id).eq('user_id', user.id)`
- CASCADE on the FK will auto-delete messages
- Return 200: `{ success: true }`
- Error handling: handleAPIError(error, 'API:Conversations:DELETE')

IMPORTANT: Both files must import from the same libraries as messages/route.ts:
- `import { createClient } from '@/lib/supabase/server'`
- `import { createClient as createAdminClient } from '@supabase/supabase-js'`
- `import { handleAPIError } from '@/lib/api/error-handler'`
- `import { parseRequestBody, createConversationSchema, updateConversationSchema } from '@/lib/api/schemas'`
- `import { checkRateLimit } from '@/lib/rate-limit'`

Define getSupabaseAdmin() locally in each file (same as messages/route.ts pattern).

For the [id] route, the Next.js 15 App Router pattern for dynamic route params is:
```typescript
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  // ...
}
```
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to verify no type errors. Check files exist:
- `ls app/api/conversations/route.ts`
- `ls app/api/conversations/\[id\]/route.ts`
  </verify>
  <done>
GET /api/conversations returns conversation list. POST /api/conversations creates conversations. PATCH /api/conversations/[id] renames. DELETE /api/conversations/[id] deletes with CASCADE. All routes have auth, rate limiting, validation, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auto-title endpoint and update messages API</name>
  <files>
    app/api/conversations/[id]/title/route.ts
    app/api/chat/messages/route.ts
  </files>
  <action>
**app/api/conversations/[id]/title/route.ts** (POST):

This endpoint generates a conversation title from the first user message and AI response using Bedrock (same pattern as app/api/chat/route.ts which already uses BedrockRuntimeClient).

- Auth check
- Rate limit: standard
- Parse body with `parseRequestBody(request, generateTitleSchema)` to get userMessage and aiMessage
- Extract `id` from params
- Verify conversation belongs to user: `adminSupabase.from('conversations').select('id').eq('id', id).eq('user_id', user.id).single()`
- If not found, return 404
- Generate title using Bedrock ConverseCommand (NOT ConverseStreamCommand - we want the full response, not streaming):
  ```typescript
  const bedrockClient = new BedrockRuntimeClient({
    region: process.env.AWS_REGION || 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
    },
  });

  const command = new ConverseCommand({
    modelId: 'us.anthropic.claude-3-5-haiku-20241022-v1:0',
    messages: [{
      role: 'user',
      content: [{ text: `Summarize this conversation in 3-8 words for a sidebar title. Return ONLY the title, no quotes, no punctuation at the end, no explanation.\n\nUser: ${userMessage.slice(0, 300)}\nAssistant: ${aiMessage.slice(0, 300)}` }],
    }],
    inferenceConfig: { maxTokens: 30, temperature: 0.3 },
  });
  ```
- Extract title from response: `response.output?.message?.content?.[0]?.text?.trim()`
- Clean title: remove surrounding quotes, limit to 100 chars
- Update conversation: `adminSupabase.from('conversations').update({ title: cleanedTitle }).eq('id', id).eq('user_id', user.id)`
- Return: `{ title: cleanedTitle }`
- Wrap entire Bedrock call in try/catch. On Bedrock failure, generate a fallback title from first 5 words of userMessage + "..." and still save it. This endpoint must never fail loudly.

**app/api/chat/messages/route.ts** (UPDATE):

Modify the existing file:

1. GET handler: Add conversation_id query parameter support
   - After the existing `before` param extraction, add: `const conversationId = searchParams.get('conversation_id')`
   - After building the base query, add: `if (conversationId) { query = query.eq('conversation_id', conversationId); }`
   - This is backward-compatible: if no conversation_id is provided, returns all messages (existing behavior)

2. POST handler: Add conversation_id to insert
   - The updated `saveMessageSchema` already requires conversation_id
   - Change destructure from `const { role, content } = result` to `const { role, content, conversation_id } = result`
   - Add `conversation_id` to the insert object: `{ user_id: user.id, role, content, conversation_id }`
   - Also update the conversation's updated_at timestamp after saving a message:
     ```typescript
     // Update conversation's updated_at to keep sidebar order fresh
     await adminSupabase
       .from('conversations')
       .update({ updated_at: new Date().toISOString() })
       .eq('id', conversation_id);
     ```
   - This ensures recent conversations float to the top of the sidebar list

IMPORTANT: Use Haiku 3.5 (us.anthropic.claude-3-5-haiku-20241022-v1:0) for title generation, NOT Sonnet 4.5. Title generation should be fast and cheap.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -30` to verify no type errors. Check files exist:
- `ls app/api/conversations/\[id\]/title/route.ts`
Verify messages route has conversation_id: `grep -n 'conversation_id' app/api/chat/messages/route.ts`
  </verify>
  <done>
Auto-title endpoint generates 3-8 word titles via Haiku 3.5 with fallback. Messages API filters by conversation_id on GET and includes conversation_id on POST insert. Conversation updated_at is refreshed on each new message to maintain sidebar recency order.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully (catches any Next.js route issues)
3. All five route files exist and export the correct HTTP methods
4. lib/api/schemas.ts exports createConversationSchema, updateConversationSchema, generateTitleSchema, and updated saveMessageSchema
</verification>

<success_criteria>
- Conversation CRUD API routes are functional with auth, rate limiting, Zod validation, and error handling
- Messages API supports conversation_id filtering (GET) and insertion (POST)
- Auto-title endpoint generates concise titles via Bedrock Haiku with graceful fallback
- saveMessageSchema requires conversation_id (UUID) for all message saves
- All routes follow existing project patterns (adminSupabase, handleAPIError, checkRateLimit)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-conversation-ui/10-01-SUMMARY.md`
</output>
